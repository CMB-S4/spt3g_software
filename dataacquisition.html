<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Data Acquisition &#8212; SPT3G Software  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css?v=279e0f84" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Auto-documentation" href="autodoc.html" />
    <link rel="prev" title="Units" href="units.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="autodoc.html" title="Auto-documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPT3G Software  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data Acquisition</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-acquisition">
<h1><a class="toc-backref" href="#id1" role="doc-backlink">Data Acquisition</a><a class="headerlink" href="#data-acquisition" title="Link to this heading">¶</a></h1>
<p>This software provides, in addition to data processing, facilities for data acquisition. The goal is to have a unified framework for simulations, data acquisition, and analysis.</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#data-acquisition" id="id1">Data Acquisition</a></p>
<ul>
<li><p><a class="reference internal" href="#dfmux" id="id2">DfMux</a></p>
<ul>
<li><p><a class="reference internal" href="#bolometer-data" id="id3">Bolometer Data</a></p>
<ul>
<li><p><a class="reference internal" href="#sctp" id="id4">SCTP</a></p></li>
<li><p><a class="reference internal" href="#udp" id="id5">UDP</a></p></li>
<li><p><a class="reference internal" href="#legacy-boards" id="id6">Legacy Boards</a></p></li>
<li><p><a class="reference internal" href="#data-structures" id="id7">Data Structures</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#housekeeping-data" id="id8">Housekeeping Data</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#building-timestreams" id="id9">Building Timestreams</a></p>
<ul>
<li><p><a class="reference internal" href="#the-wiring-map" id="id10">The Wiring Map</a></p></li>
<li><p><a class="reference internal" href="#dfmuxcollator" id="id11">DfMuxCollator</a></p></li>
<li><p><a class="reference internal" href="#collecting-data-to-a-netcdf-file" id="id12">Collecting data to a NetCDF file</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#core-tools" id="id13">Core Tools</a></p>
<ul>
<li><p><a class="reference internal" href="#g3eventbuilder" id="id14">G3EventBuilder</a></p></li>
<li><p><a class="reference internal" href="#g3triggeredbuilder" id="id15">G3TriggeredBuilder</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ledgerman" id="id16">ledgerman</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="dfmux">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">DfMux</a><a class="headerlink" href="#dfmux" title="Link to this heading">¶</a></h2>
<section id="bolometer-data">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Bolometer Data</a><a class="headerlink" href="#bolometer-data" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">dfmux</span></code> project provides two classes that can be used for event-driven acquisition of bolometer timestreams from IceBoards. The core class, <code class="docutils literal notranslate"><span class="pre">dfmux.DfMuxCollector</span></code>, listens for data from one or more IceBoards, passing the resulting data to a <code class="docutils literal notranslate"><span class="pre">dfmux.DfMuxBuilder</span></code> object to which the collected data is reported. The <code class="docutils literal notranslate"><span class="pre">dfmux.DfMuxBuilder</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">G3EventBuilder</span></code> (see <a class="reference internal" href="#g3eventbuilder">G3EventBuilder</a> below) that assembles mux packets from one or more <code class="docutils literal notranslate"><span class="pre">DfMuxCollector</span></code> objects into frames, with one sample from each readout channel per frame. To do this, it is passed either the number of boards to expect for a complete sample or a list of the serial numbers of boards to use.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3Pipeline</span><span class="p">()</span>
<span class="n">builder</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxBuilder</span><span class="p">([</span><span class="mi">136</span><span class="p">])</span>
<span class="n">collector</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxCollector</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;iceboard0136.local&quot;</span><span class="p">])</span>
<span class="n">collector</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example listens for data from the IceBoard with serial number 136 using SCTP (see below), passing the resulting data to the specified DfMuxBuilder. A list of serial numbers in a given pydfmux hardware map can be obtained using a command like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">serials</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">board</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span> <span class="k">for</span> <span class="n">board</span> <span class="ow">in</span> <span class="n">hwm</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pydfmux</span><span class="o">.</span><span class="n">IceBoard</span><span class="p">)]</span>
</pre></div>
</div>
<p>This library supports data acquisition using either of two data transport mechanisms: SCTP (newer firmware than 11.3 only) and multicast UDP.</p>
<section id="sctp">
<h4><a class="toc-backref" href="#id4" role="doc-backlink">SCTP</a><a class="headerlink" href="#sctp" title="Link to this heading">¶</a></h4>
<p>Extremely new (as-yet unreleased) IceBoard firmwares support using SCTP as a data transport. In this mode, a <code class="docutils literal notranslate"><span class="pre">DfMuxCollector</span></code> object connects to the IceBoard, opening a data connection over which streaming samples are transported to the DAQ computer. This connection is error-tolerant and point-to-point, so the collector must be passed a list of boards to listen to. SCTP is used when the collector is created with a list of board hostnames and the builder argument <em>first</em>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">collector</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxCollector</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;iceboard0136.local&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that, when using SCTP for data transport on Linux, you may need to load the sctp kernel module by running <code class="docutils literal notranslate"><span class="pre">modprobe</span> <span class="pre">sctp</span></code>. On versions of the Linux kernel earlier than 4.16, you may also need to instantiate one DfMuxCollector per board. (This is the default behavior of <code class="docutils literal notranslate"><span class="pre">record_bolodata.py</span></code>).</p>
</section>
<section id="udp">
<h4><a class="toc-backref" href="#id5" role="doc-backlink">UDP</a><a class="headerlink" href="#udp" title="Link to this heading">¶</a></h4>
<p>The default mode of data acquisition is multicast UDP, which makes the data acquisition system passive. When using multicast UDP (mandatory on firmwares 11.3 and earlier, otherwise optional), the <code class="docutils literal notranslate"><span class="pre">DfMuxCollector</span></code> must be passed the IP address of an interface <em>on the DAQ computer</em> on which to listen for detector data and, optionally, a list of board serial numbers. (The list of board serial numbers is optional when using only one Ethernet interface, but <em>must</em> be passed if using Linux on a system with multiple Ethernet interfaces as a result of a Linux kernel multicast socket routing bug.) UDP mode is activated when passing a single listening IP address and the builder object <em>second</em>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">collector</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxCollector</span><span class="p">(</span><span class="s2">&quot;192.168.1.4&quot;</span><span class="p">,</span> <span class="n">builder</span><span class="p">,</span> <span class="p">[</span><span class="mi">136</span><span class="p">])</span>
</pre></div>
</div>
<p>If using multicast UDP for data transport, note that the mux system can deliver large numbers of UDP packets rapidly. If you see warnings about missed samples, you may need to increase the maximum size of the kernel UDP receive queue. On Linux, this can be accomplished by changing the value in <code class="docutils literal notranslate"><span class="pre">/proc/sys/net/core/rmem_max</span></code>. On FreeBSD and Mac OS X, the maximum is in the sysctl <code class="docutils literal notranslate"><span class="pre">kern.ipc.maxsockbuf</span></code>. A value of 5000000000 seems to work well.</p>
<p>On some versions of Linux with 128x DfMux firmware and multicast UDP for data transport, you will need to disable strict reverse-path validation in the kernel to take data. This can be accomplished by setting the sysctl <code class="docutils literal notranslate"><span class="pre">net.ipv4.conf.all.rp_filter</span></code> to 0. Depending on our system configuration, you may also need to set the corresponding per-interface sysctl (replace <code class="docutils literal notranslate"><span class="pre">all</span></code> with an interface name) corresponding to the network interface to which the DfMux boards are connected.</p>
<p>Lower data-loss rates with UDP can also often be achieved by setting the Qualityof-Service rules (“QoS”) on your ethernet switch to respect DSCP indications (just look for the acronym).</p>
</section>
<section id="legacy-boards">
<h4><a class="toc-backref" href="#id6" role="doc-backlink">Legacy Boards</a><a class="headerlink" href="#legacy-boards" title="Link to this heading">¶</a></h4>
<p>This code can also be used to collect data from legacy boards with DAN firmware if you are so inclined by using the <code class="docutils literal notranslate"><span class="pre">dfmux.LegacyDfMuxCollector</span></code> class in place of <code class="docutils literal notranslate"><span class="pre">dfmux.DfMuxCollector</span></code>.</p>
</section>
<section id="data-structures">
<h4><a class="toc-backref" href="#id7" role="doc-backlink">Data Structures</a><a class="headerlink" href="#data-structures" title="Link to this heading">¶</a></h4>
<p>Frames generated by DfMuxBuilder contain two keys: “EventHeader” and “DfMux”.</p>
<p>“EventHeader” is a <code class="docutils literal notranslate"><span class="pre">G3Time</span></code> object containing the IRIG time of the first sample in the frame. If all the boards are synchronized correctly, this will also be the timestamp attached to all DfMux board samples.</p>
<p>“DfMux” is an object of type <code class="docutils literal notranslate"><span class="pre">DfMuxMetaSample</span></code>. This is a dictionary that maps board serial number to a <code class="docutils literal notranslate"><span class="pre">DfMuxBoardSamples</span></code> object. This in turn is a dictionary that maps readout module number (0-7) to a <code class="docutils literal notranslate"><span class="pre">DfMuxSample</span></code> object. This contains the IRIG timestamp for the data in its <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> member as well as a 128-element array of all the bolometer data in <code class="docutils literal notranslate"><span class="pre">Samples</span></code>, stored with I and Q interleaved (so element 0 is channel 1/I, 1 is channel 1/Q, 2 is channel 2/I, etc.).</p>
<p>As an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">channel2q</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;DfMux&#39;</span><span class="p">][</span><span class="n">frame</span><span class="p">[</span><span class="s1">&#39;DfMux&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>This retrieves data from the first board in the array, module 1, channel 2, modulation Q.</p>
</section>
</section>
<section id="housekeeping-data">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Housekeeping Data</a><a class="headerlink" href="#housekeeping-data" title="Link to this heading">¶</a></h3>
<p>DfMux board housekeeping is collected by the <code class="docutils literal notranslate"><span class="pre">dfmux.HousekeepingConsumer</span></code> class. It will query all of the boards in the most recent wiring map (see <cite>The Wiring Map</cite>) when a Housekeeping frame appears in the datastream, placing the results in the key <code class="docutils literal notranslate"><span class="pre">DfMuxHousekeeping</span></code>.</p>
<p>Housekeeping frames at fixed intervals can be generated using <code class="docutils literal notranslate"><span class="pre">dfmux.PeriodicHousekeepingCollector</span></code>. Note that collecting housekeeping information generates noise in detector timestreams and should be done only at times that you do not care about the data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Housekeeping collecting can take up to a few seconds. If you are worried about pipeline stalls, you may want to run the housekeeping consumer in a subprocess (see <code class="docutils literal notranslate"><span class="pre">G3Pipeline.Add()</span></code>).</p>
</div>
<p>The resulting data are stored in a <code class="docutils literal notranslate"><span class="pre">dfmux.DfMuxHousekeepingMap</span></code> map, indexed by board serial number. This can be cross-correlated to the wiring map data. Mezzanines, modules, and channels stored in the elements are 1-indexed, matching the convention from pydfmux.</p>
<p>For ease of cross-correlation, there is a function <code class="docutils literal notranslate"><span class="pre">dfmux.HousekeepingForBolo</span></code> that can will look up the housekeeping information for a particular named bolometer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hk</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">HousekeepingForBolo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hkmap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wiringmap</span><span class="p">,</span> <span class="s1">&#39;Bolometer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, this only returns information for the channel (notably containing the carrier amplitude and frequency). If you want the board, mezzanine, module, and channel information returned as a tuple, in that order, pass the keyword argument <code class="docutils literal notranslate"><span class="pre">all_hk=True</span></code>.</p>
</section>
</section>
<section id="building-timestreams">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Building Timestreams</a><a class="headerlink" href="#building-timestreams" title="Link to this heading">¶</a></h2>
<p>All analysis tools use data in the form of G3Timestreams, indexed by bolometer ID. Timestreams are typically stored in a Scan (see <a class="reference internal" href="frames.html"><span class="doc">Frames</span></a>) frame, which is constructed from a wiring map and Timepoint frames using <a class="reference internal" href="#dfmuxcollator">DfMuxCollator</a>.</p>
<section id="the-wiring-map">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">The Wiring Map</a><a class="headerlink" href="#the-wiring-map" title="Link to this heading">¶</a></h3>
<p>The wiring map, stored in a Wiring frame at the beginning of data taking, stores the mapping between bolometer ID and (Board Slot/Address, SQUID, Readout channel) tuples – the information required to connect a <code class="docutils literal notranslate"><span class="pre">DfMuxMetaSample</span></code> object to bolometer samples. The wiring map is stored as the key <code class="docutils literal notranslate"><span class="pre">WiringMap</span></code> in an object of type <code class="docutils literal notranslate"><span class="pre">DfMuxWiringMap</span></code> in a Wiring frame. In almost all cases, this is inserted into the data stream by the <code class="docutils literal notranslate"><span class="pre">PyDfMuxHardwareMapInjector</span></code> module. This module is typically inserted as the first module following the <code class="docutils literal notranslate"><span class="pre">DfMuxBuilder</span></code> and takes a pydfmux hardware map as input (note: <em>not</em> a pydfmux session):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">dfmux</span><span class="o">.</span><span class="n">PyDfMuxHardwareMapInjector</span><span class="p">,</span> <span class="n">pydfmux_hwm</span><span class="o">=</span><span class="n">hwm</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="dfmuxcollator">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">DfMuxCollator</a><a class="headerlink" href="#dfmuxcollator" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DfMuxCollator</span></code> class builds Scan frames (and timestreams) from Timepoint frames using the wiring map. Scan boundaries are signalled by the insertion of empty Scan frames into the data stream. When the <code class="docutils literal notranslate"><span class="pre">DfMuxCollator</span></code> object encounters a Scan frame, it will do the following:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Accumulate all subsequent DfMux samples into two timestream maps, indexed by the bolometer IDs stored in the wiring map: <code class="docutils literal notranslate"><span class="pre">RawTimestreams_I</span></code> and <code class="docutils literal notranslate"><span class="pre">RawTimestreams_Q</span></code>. Any samples for detectors not listed in the wiring map will be discarded. Accumulation ends with the next scan frame or the end of data processing, whichever comes first.</p></li>
<li><p>Accumulate all scalar floating point numbers in the timepoint frames into timestreams with the same names. This is useful to store non-bolometer data such as telescope pointing.</p></li>
<li><p>By default, FLAC compression is enabled for all bolometer timestreams and the source timepoint frames are discarded. These can be changed using the two arguments to the constructor of <code class="docutils literal notranslate"><span class="pre">DfMuxCollator</span></code>.</p></li>
</ol>
</div></blockquote>
<p>Empty scan frames can be inserted using a short Python module at appropriate boundaries. A trivial example is the <code class="docutils literal notranslate"><span class="pre">dfmux.FixedLengthScans</span></code> module, which makes “scans” of some integer number of mux samples (by default, 1000 frames). In practice, you would want to break scans by GCP commands or analysis of telescope pointing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">dfmux</span><span class="o">.</span><span class="n">PyDfMuxHardwareMapInjector</span><span class="p">,</span> <span class="n">pydfmux_hwm</span><span class="o">=</span><span class="n">hwm</span><span class="p">)</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">dfmux</span><span class="o">.</span><span class="n">FixedLengthScans</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxCollator</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="collecting-data-to-a-netcdf-file">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Collecting data to a NetCDF file</a><a class="headerlink" href="#collecting-data-to-a-netcdf-file" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">dfmux.NetCDFDump</span></code> module takes timepoint frames and writes them to a NetCDF 3 file that can be opened using a variety of software packages, most notably KST, which will also monitor the file for updates. All sample points present in the wiring map are written to the output file with both I and Q demodulations, denoted by an <code class="docutils literal notranslate"><span class="pre">_I</span></code> or <code class="docutils literal notranslate"><span class="pre">_Q</span></code> suffix appended to the bolometer ID in the wiring map. In addition, a field called <code class="docutils literal notranslate"><span class="pre">Time</span></code> will be added containing the time of the sample (from the <code class="docutils literal notranslate"><span class="pre">EventHeader</span></code> key) in seconds since the UNIX epoch (Jan. 1, 1970). This time can be decoded using the python <code class="docutils literal notranslate"><span class="pre">time</span></code> module.</p>
<p>An example follows, including the addition of the wiring map from pydfmux and construction of the event builder:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3Pipeline</span><span class="p">()</span>
<span class="n">builder</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxBuilder</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hwm</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">pydfmux</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">dfmux</span><span class="o">.</span><span class="n">IceBoard</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()))</span>
<span class="n">collector</span> <span class="o">=</span> <span class="n">dfmux</span><span class="o">.</span><span class="n">DfMuxCollector</span><span class="p">(</span><span class="s2">&quot;192.168.1.4&quot;</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">builder</span><span class="p">)</span>

<span class="c1"># Insert current hardware map into data stream. This is critical to get the</span>
<span class="c1"># channel -&gt; board/module mapping needed to do anything useful with the data</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">dfmux</span><span class="o">.</span><span class="n">PyDfMuxHardwareMapInjector</span><span class="p">,</span> <span class="n">pydfmux_hwm</span><span class="o">=</span><span class="n">hwm</span><span class="p">)</span>

<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">dfmux</span><span class="o">.</span><span class="n">NetCDFDump</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>This is contained in runnable form in <code class="docutils literal notranslate"><span class="pre">dfmux/bin/ledgerman.py</span></code>.</p>
<p>Note that the version of KST installed from the default package repository under Ubuntu may not have support for reading NetCDF files produced by ledgerman. The version available from the KST PPA repository is compiled with NetCDF support (<a class="reference external" href="http://launchpad.net/~kst-plot/+archive/ubuntu/ppa">http://launchpad.net/~kst-plot/+archive/ubuntu/ppa</a>).</p>
</section>
</section>
<section id="core-tools">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Core Tools</a><a class="headerlink" href="#core-tools" title="Link to this heading">¶</a></h2>
<section id="g3eventbuilder">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">G3EventBuilder</a><a class="headerlink" href="#g3eventbuilder" title="Link to this heading">¶</a></h3>
<p>Implements an asynchronous frame builder based on frame objects delivered to its non-blocking <code class="docutils literal notranslate"><span class="pre">AsyncDatum()</span></code> call. When these arrive, the object calls the pure virtual method <code class="docutils literal notranslate"><span class="pre">ProcessNewData()</span></code> from a main thread. This method is responsible for assembling the data and eventually passing a complete frame to <code class="docutils literal notranslate"><span class="pre">FrameOut()</span></code>, which will begin processing it in the pipeline. This is a C++-only abstract base class and is useful only when building a new data acquisition system.</p>
</section>
<section id="g3triggeredbuilder">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">G3TriggeredBuilder</a><a class="headerlink" href="#g3triggeredbuilder" title="Link to this heading">¶</a></h3>
<p>This is the analog of G3EventBuilder for non-self-triggering systems (i.e. systems that poll for new data rather than streaming it). This can be used for once-every-N DAQ tasks like collecting housekeeping data.</p>
</section>
</section>
<section id="ledgerman">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">ledgerman</a><a class="headerlink" href="#ledgerman" title="Link to this heading">¶</a></h2>
<p>An example tool called <code class="docutils literal notranslate"><span class="pre">ledgerman</span></code> is included that collects data from the mux boards and writes it to a NetCDF file that can be read with kst. It is installed under <code class="docutils literal notranslate"><span class="pre">bin</span></code> in your build directory and will be available in your PATH if you have run <code class="docutils literal notranslate"><span class="pre">env-shell.sh</span></code>.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>ledgerman<span class="w"> </span>/path/to/a/pydfmux/hardware/map.yaml<span class="w"> </span>output.nc
</pre></div>
</div>
<p>To see the frames as they go by:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>ledgerman<span class="w"> </span>-v<span class="w"> </span>/path/to/a/pydfmux/hardware/map.yaml<span class="w"> </span>output.nc
</pre></div>
</div>
<p>Like the other modules, you may see a few warnings about missing data immediately after it starts in the event that it starts collecting data midway through a sample. There should not be any warning messages after that.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Data Acquisition</a><ul>
<li><a class="reference internal" href="#dfmux">DfMux</a><ul>
<li><a class="reference internal" href="#bolometer-data">Bolometer Data</a><ul>
<li><a class="reference internal" href="#sctp">SCTP</a></li>
<li><a class="reference internal" href="#udp">UDP</a></li>
<li><a class="reference internal" href="#legacy-boards">Legacy Boards</a></li>
<li><a class="reference internal" href="#data-structures">Data Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#housekeeping-data">Housekeeping Data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-timestreams">Building Timestreams</a><ul>
<li><a class="reference internal" href="#the-wiring-map">The Wiring Map</a></li>
<li><a class="reference internal" href="#dfmuxcollator">DfMuxCollator</a></li>
<li><a class="reference internal" href="#collecting-data-to-a-netcdf-file">Collecting data to a NetCDF file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#core-tools">Core Tools</a><ul>
<li><a class="reference internal" href="#g3eventbuilder">G3EventBuilder</a></li>
<li><a class="reference internal" href="#g3triggeredbuilder">G3TriggeredBuilder</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ledgerman">ledgerman</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="units.html"
                          title="previous chapter">Units</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="autodoc.html"
                          title="next chapter">Auto-documentation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/dataacquisition.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="autodoc.html" title="Auto-documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="units.html" title="Units"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPT3G Software  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data Acquisition</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>