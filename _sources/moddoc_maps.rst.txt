----
maps
----

The maps project defines map projections, along with G3SkyMap subclasses that provide sky maps in those map projections and tools for format/projection conversions of these data types.

In addition, this library contains three pipeline modules (MapBinner, SingleDetectorMapBinner, and SingleDetectorBoresightBinner) to make binned maps from time-ordered data, as well as a module (MapMockObserver) to mock-observe a provided sky map, generating fake time-ordered-data from it corresponding to some stored instrument pointing itinerary. A few other utility pipeline modules (described below) are provided for some map manipulation tasks.

The key data types defined here are:


HealpixSkyMap
  Implements Healpix over all or a fraction of the sky, either in nested or ring mode. The underlying sky map data are represented in one of three ways: as a dense 1-D array (full sky), as a locally-dense region surrounded by zeroes (ring mode only), or as a list of non-zero pixels and their values. The second two modes efficiently represent partial-sky maps.

FlatSkyMap
  Implements a flat-sky map (similar to a 2D numpy array) in any of the supported projections. The stored map is either a dense 2D array, or a locally dense region (a set of neighboring columns containing non-zero values, each of which contains a single contiguous block of non-zero values).

Map Attributes
==============

The following attributes are common to all G3SkyMap subclasses:

``coord_ref``
  The coordinate system on the sky to which each map pixel is referenced, stored as an instance of the ``MapCoordReference`` enum.  Currently supported coordinate systems are ``Equatorial`` (FK5 J2000), ``Galactic`` and ``Local`` (telescope azimuth and elevation).

``pol_type``
  The Stokes polarization of the map object, which is an instance of the ``MapPolType`` enum, and can have the value ``T``, ``Q``, ``U`` or None.

``pol_conv``
  The polarization convention used to encode the Q and U Stokes orientations relative to the coordinate axes.  This attribute is an instance of the ``MapPolConv`` enum, which can have the value ``IAU``, ``COSMO`` or None.  Both IAU and COSMO polarization conventions are supported in polarization-aware functions (e.g. ``FlattenPol``), but most default to using the IAU convention.  Warnings will be raised when a polarized map is used without a polarization convention set.  Use the ``SetPolConv`` pipeline module to change the polarization convention between IAU and COSMO for an entire map frame.  This will result in flipping the sign of all pixels in the ``U`` map as well as the ``TU`` and ``QU`` weights.
  
``units``
  The units system in which the map is computed, stored as an instance of the ``G3TimestreamUnits`` enum, typically ``Tcmb``.
  
``weighted``
  A boolean attribute indicating whether the data in the map have been normalized by the inverse of the appropriate Mueller matrix (``weighted=False``) or not (``weighted=True``).  See more information on map weights below.

File Format Conversions
=======================

We support writing maps into FITS files that can be read with other tools (such as DS9), using the ``fitsio.save_skymap_fits`` function.  FITS files with compatible headers can be read in using the ``fitsio.load_skymap_fits`` function.

T, Q, U and corresponding G3SkyMapWeights objects are written to a single file as a sequence of HDUs.  FlatSkyMap objects are stored in dense format (see below) to CompImageHDU objects if compression is enabled, and otherwise stored in dense format to standard ImageHDU objects.  The latter can be loaded using "old style" fits readers, such as the ``idlastro`` fits utilities.

HealpixSkyMap objects are stored in a sequence of BinTableHDU objects, a format that is compatible with the ``healpy.read_map`` function.  Dense maps (see below) are stored using implicit indexing, and sparse maps are stored using explicit indexing with an additional pixel index column.

Indexing
========

Values in maps can be set and retrieved using the standard python (or C++) ``[]`` operator. Both flat and Healpix maps support a 1-D indexing convention. For flat-sky maps, this 1-D index follows C ordering; for Healpix maps, this is the normal 1-D Healpix pixel number. Flat-sky maps also accept 2-D indices, which have ordering following normal language conventions for 2-D indices ((y, x) in Python, (x, y) in C++).

Note that sky maps *do not* support numpy-style slicing operations, except for 2-D indexing of flat-sky maps (see below), which makes a copy of the underlying map data.  To perform operations with other numpy arrays, use ``numpy.asarray``, which will convert the map to its dense representation (see below) and provides read-write access the map's internal buffer, which requires no meaningful CPU time or memory.

Sparsity
========

By default, both Healpix and flat-sky maps are initialized in sparse mode. This imposes a slight performance penalty but will result in the map storing only non-zero portions (with caveats, see details above), substantially reducing RAM usage. Some map operations, in particular casting to numpy arrays, will result in the implicit conversion of the map to dense storage, which can result in sudden increases in RAM usage. The current sparsity mode can be examined or changed with the ``sparse`` property (flat sky maps) or the ``dense``, ``ringsparse``, or ``indexedsparse`` properties (Healpix maps). Serialization to ``.g3`` files will maintain the current sparsity scheme, as do arithmetic operators where possible. Serialization to ``.fits`` files implicitly converts flat sky maps to dense mode, but preserves the sparsity of Healpix maps.  The current number of stored pixels can be obtained using the ``npix_allocated`` property, and the number of non-zero pixels can be obtained using the ``npix_nonzero`` property.  Dense maps can be efficiently compactified in memory using the ``G3SkyMap.compact`` method, or the ``CompactMaps`` pipeline module.

Beyond paying attention to implicit conversions to dense storage and the performance impact of sparse storage (which is small, at least for FlatSkyMap objects), users of this code do not need to worry about the storage mode--all interfaces are identical in all modes.

Masking
=======

Maps containing only boolean data for each pixel are stored as ``G3SkyMapMask`` objects.  Such mask objects have a ``.parent`` attribute which is a shallow clone of the map object with which they are associated (to check for shape compatibility).

Masks are returned when using comparison operators with map objects, e.g.  ``map1 > 5`` or ``map1 == map2``.  The supported comparison operators are: ``>, >=, ==, !=, <=, <``.  Masks can also be combined together using logical operators, e.g. ``mask3 = mask1 & mask2`` or ``mask1 ^= mask2``.  The supported comparison operators are: ``&, &=, |, |=, ^, ^=``.  Masks can also be checked for equality to other masks using ``==`` and ``!=`` operators.

Mask objects can be ``clone``'ed the same way as maps.  A map can be converted to a boolean mask using ``G3SkyMap.to_mask()``, which returns a mask which is ``True`` wherever the map is non-zero (optionally excluding nan or inf pixels).  A mask can be converted back to a map object using ``G3SkyMapMask.to_map()``, which returns a sparse, unit-less, unweighted, unpolarized map object of the same type as ``G3SkyMapMask.parent``, containing double ``1.0`` wherever the mask is ``True``.

Masks can also be applied to maps or masks using the appropriate ``.apply_mask`` method, with optional inversion; alternatively maps can also be directly multiplied by a compatible mask object.  A list of non-zero pixels can be returned using ``.nonzero()`` (note that this returns a single vector of pixel positions), and mask contents can be checked using ``.all()``, ``.any()`` and ``.sum()``.  Mask contents can be inverted in-place using ``.invert()``.

Mask objects cannot be accessed using ``numpy`` slicing, or converted directly to arrays, because ``numpy`` does not represent boolean values as single bits.  To be able to use ``numpy`` tools with masks, you need to first convert the mask to a dense map using ``.to_map()``.  All associated methods of the parent map are accessible as attributes of the mask object in python, e.g. ``mask.angles_to_pixels()`` works as one would expect.

Mask Memory Usage
-----------------

The current implementation of masks is to use a dense ``std::vector<bool>`` as the data storage backend, which uses 64x less memory than a dense map (``std::vector<double>``) of the same dimensions.  This implementation is sufficient for ``FlatSkyMap`` objects, since these are typically O(50\%) full populated in their sparse state; however, the memory savings for ``HealpixSkyMap`` objects is not as significant when observing sufficiently small patches of sky.  Future work would enable a similar sparse storage backend for masks.

In general, when working with high-resolution maps of any sort, it is important to think carefully about doing the sorts of operations that can balloon memory usage, e.g. taking care to preserve the sparsity of maps by avoiding numpy operations if possible, or using in-place operations to avoid unintentionally creating extra maps or masks in memory.

Statistics
==========

Most ``numpy.ufunc``-like methods are defined for map objects, namely ``.all(), .any(), .sum(), .mean(), .median(), .var(), .std(), .min(), .max(), .argmin(), .argmax()``.  All methods take an optional ``where`` argument, which can be a compatible ``G3SkyMapMask`` object, or size-compatible 1-D ``numpy`` array that can be converted into one.  In addition, these methods are called under the hood when using the numpy equivalent functions (``numpy.all()``, etc), in order to preserve the sparsity of the input map.  Methods that ignore ``NaN`` values are also defined (``.nansum()``, etc), which behave much like the standard methods, except that calling ``numpy.nansum()`` and friends on a map object does *not* preserve sparsity.

Map values can be tested using ``.isnan(), .isinf(), .isfinite()`` methods as well; these return ``G3SkyMapMask`` objects.

Map Interpolation
=================

Several interpolation and rebinning utilities are provided.  The method ``G3SkyMap.get_interp_values`` can be used for extracting map values at arbitrary sky positions using bilinear interpolation.  The method ``G3SkyMap.rebin`` can be used to downgrade the map resolution in a way that preserves the total power within each map pixel.

The functions ``healpix_to_flatsky`` and ``flatsky_to_healpix`` functions are provided to reproject maps between flat sky and curved sky systems, with options to use interpolation or rebinning to improve the accuracy of the reprojection.

The more general ``reproj_map`` function can also be used to convert between flat sky projections.

*Note:* The interpolation routine for healpix maps produces results that differ from those of the equivalent ``healpy.get_interp_val`` routine.  The interpolation routine implemented here is area-preserving in the computation of bilinear weights, whereas the ``healpy`` routine is not.

Map Weights
===========

The ``G3SkyMapWeights`` class combines the six unique components of the Mueller weight matrix into one object.  The individual matrix terms can be accessed using the attributes ``G3SkyMapWeights.TT``, etc, or as keyed elements (e.g. ``weights['TT']``).  The full matrix for an individual map pixel can be accessed using the standard ``[]`` operator.  In python, this returns a symmetric 3x3 numpy array that is a copy of the values in the underlying maps, and in C++ this returns a MuellerMatrix object, with scalar attributes ``MuellerMatrix.tt``, etc that are writable references to elements of the underlying map objects.  The ``G3SkyMapWeights.polarized`` attribute determines whether the weight structure contains polarization information.  For unpolarized weights, only the ``TT`` element is set, and the ``[]`` operator returns a scalar value in python, and a MuellerMatrix with just the TT element set in C++.

In C++ there is also a StokesVector object that is analogous to the MuellerMatrix object.  It has scalar attributes StokesVector.t etc, that are writable references to elements of map objects.  Matrix operations on the StokesVector and MuellerMatrix objects are well defined.

Weights are removed from or applied to a set of Stokes T/Q/U maps simultaneously, using the ``remove_weights`` or ``apply_weights`` functions, or their corresponding pipeline modules.

Map Frames and Pipelines
========================

Maps and associated weights are generally stored in memory and on disk in ``G3Frames`` of type ``G3FrameType.Map``, with keys ``'T', 'Q', 'U', 'Wpol'`` defined for polarized maps, and ``'T', 'Wunpol'`` defined for unpolarized maps.  Map frames can be checked for validity using the ``ValidateFrames`` pipeline module, which raises errors or warnings for missing keys or inconsistent attributes.

Map frames can be manipulated in a pipeline using some memory-efficient pipeline modules.  Weights can be applied or removed from their corresponding Stokes maps using the ``ApplyWeights`` or ``RemoveWeights`` pipeline modules.  Maps can be converted to polarized or unpolarized versions using the ``MakeMapPolarized`` and ``MakeMapUnpolarized`` modules.  They can also be compactified to their most sparse representation using the ``CompactMaps`` module.

Existing maps can be injected into a pipeline using the ``InjectMaps`` module, and map stubs can be injected using ``InjectMapStub`` or ``ReplicateMaps``.  Maps can also be extracted from a pipeline using the ``ExtractMaps`` module.

Flat Sky Map Projections
========================

For flat-sky maps, we support the following map projections:

ProjSansonFlamsteed
  Sanson-Flamsteed (also called the sinusoidal projection). It has equal-area pixels, defined by multiplying azimuth distances by cos(latitude). Mercator-esque in that lines of constant latitude are transformed to lines of constant y. Distances are not preserved. Also known as "proj 0".

ProjPlateCarree
  The Plate-Carree projection just plots latitude and longitude on a grid: latitude lines are at constant y and equally spaced, while longitude lines are at constant x and equally spaced. Pixels are not equal-area. Also known as "proj 1".  A variant of this projection, called ProjBICEP (or "proj 9"), adjusts the resolution along x to scale with the cosine of the latitude of the center of the map.

ProjOrthographic
  The projection of the sphere onto a plane -- the sky looks like a circle. Can only show one hemisphere. Lines drawn on the map do not correspond to latitude or longitude. Pixels are not equal-area. Also known as "proj 2".

ProjStereographic
  Another projection of the sphere onto a plane that makes it look like a circle. Differs from an orthographic projection in that it lets you see both hemispheres. Popularized in the form of the UN logo. Lines drawn on the map do not correspond to latitude or longitude. Pixels are not equal-area. Also known as "proj 4".

ProjLambertAzimuthalEqualArea
  Yet another mapping of the sphere to a circle, but this one has equal-area pixels. Largely distance-preserving, which makes it particularly useful for power-spectrum analyses. Also known as "proj 5".

ProjGnomonic
  Another projection of the sphere onto a circle. This one has the property that straight lines correspond to geodesics. Does not have equal-area pixels. Can show less than half a sphere. Also known as a "tangent projection" or "proj 6".

ProjCylindricalEqualArea
  The Lambert cylindrical equal-area projection (CEA) maps the sphere to a rectangle. Has equal-area pixels. Lines of constant x correspond to constant longitude; lines of constant y are constant latitude. Latitudes get closer together (by sin(latitude)) at the poles. Also known as "proj 7".

Flat Sky Map Manipulation
=========================

Flat sky maps have additional functions defined for efficient manipulation in memory.

The ``FlattenPol`` pipeline module flattens the Q and U stokes parameters to align with the pixel coordinate grid, which is necessary for computing power spectra in the flat sky approximation.

Small patches can be extracted from and inserted into larger flat sky maps using the ``FlatSkyMap.extract_patch`` and ``FlatSkyMap.insert_patch`` methods, respectively.  Also, maps can be padded and cropped using the ``FlatSkyMap.reshape`` method, which keeps the patch centered in the output map.  All of these preserve the map pixelization and correspondence to angle on the sky.

As an equivalent and more Pythonic alternative, you can also extract portions of the map using numpy-style slicing operations (e.g. ``map[45:130,114:182]``), which will produce a map with the same contents as the numpy operation but without converting it to a dense map and with all the coordinate information set appropriately (and is equivalent to ``extract_patch()``). This also works with setting, but the coordinates have to match the sub-subcoordinates (as you would have gotten them from getting a slice or ``extract_patch()``).  Note that this slicing creates a copy of the underlying data, so in-place operations (e.g. ``map[45:130,114:182] += 5``) will work, but are not necessarily memory efficient.

Map Pointing
============

This package also provides functions and pipeline modules for creating and manipulating the quaternions necessary for mapmaking.  In general, there are two forms of quaternions that are used throughout the code: pointing quaternions and rotation quaternions.

Pointing Quaternions
--------------------

Pointing quaternions encode the two-dimensional sky coordinate angles in their vector component.  These quaternions can be created using the ``ang_to_quat`` function, and their sky coordinates extracted using the ``quat_to_ang`` function.  The various methods of the ``G3SkyMap`` classes return or accept pointing quaternions.  Note that local (horizon) coordinates have a different parity than sky coordinates (equatorial, galactic); the ``z`` vector coordinate encodes ``-sin(elevation)`` in local coordinates, but ``+sin(dec)`` in sky coordinates.

Rotation Quaternions
--------------------

Conversion between coordinate systems is done by constructing rotation quaternions.  A pointing quaternion ``q_p`` can be rotated to a new coordinate system by the rotation quaternion ``q_r`` by using quaternion multiplication: ``q_p_rot = q_r * q_p / q_r``.  For example, the module ``FillCoordTransRotations`` can be used to construct rotation quaternions for rotating detector offset coordinates into local or on-sky coordinate systems.  Rotation quaternions can be rotated into Galactic coordinates using the ``EquatorialToGalacticTransRotations`` module.

Detector Pointing
-----------------

Detector pointing timestreams are constructed by first using the ``offsets_to_quat`` function to construct the detector offset quaternion in boresight coordinates, then rotating that pointing quaternion onto the sky by applying a rotation quaternion constructed from the boresight pointing timestreams.  This is done internally for each detector in each of the mapmaking pipeline modules (``MapBinner``, ``MapMockObserver``, etc), which all require an input ``BolometerPropertiesMap`` object with offsets for each detector, and pre-computed timestreams of boresight rotation quaternions associated with each input ``Scan`` frame.


Modules in spt3g.maps
=====================
* spt3g.maps.azel.EquatorialToGalacticPointing_

* spt3g.maps.azel.LocalToAstronomicalPointing_

* spt3g.maps.coordsysmodules.AddLocalTransRotations_

* spt3g.maps.coordsysmodules.EquatorialToGalacticTransRotations_

* spt3g.maps.coordsysmodules.FillCoordTransRotations_

* spt3g.maps.fitsio.SaveMapFrame_

* spt3g.maps.map_modules.ApplyWeights_

* spt3g.maps.map_modules.CoaddMaps_

* spt3g.maps.map_modules.CompactMaps_

* spt3g.maps.map_modules.ExtractMaps_

* spt3g.maps.map_modules.FlattenPol_

* spt3g.maps.map_modules.InjectMapStub_

* spt3g.maps.map_modules.InjectMaps_

* spt3g.maps.map_modules.MakeMapsPolarized_

* spt3g.maps.map_modules.MakeMapsUnpolarized_

* spt3g.maps.map_modules.RemoveWeights_

* spt3g.maps.map_modules.ReplicateMaps_

* spt3g.maps.map_modules.ReprojectMaps_

* spt3g.maps.map_modules.SetPolConv_

* spt3g.maps.map_modules.ValidateMaps_

* spt3g.maps.quathelpers.AddTimingToPointingQuats_


.. _spt3g.maps.azel.EquatorialToGalacticPointing:

**spt3g.maps.azel.EquatorialToGalacticPointing**

Converts a set of timestreams in Scan frames representing RA and Declination
pointing of the telescope into Galactic longitude and latitude timestreams,
stored in the frame under their respective names.


*Definition:*
        ``EquatorialToGalacticPointing(frame, ra_timestream='BoresightRa', dec_timestream='BoresightDec', glon_timestream='BoresightGalLon', glat_timestream='BoresightGalLat')``




.. _spt3g.maps.azel.LocalToAstronomicalPointing:

**spt3g.maps.azel.LocalToAstronomicalPointing**

Converts a set of timestreams in Scan frames representing Az and El pointing
of the telescope into RA and Declination timestreams, stored in the frame
under their respective names.


*Definition:*
        ``LocalToAstronomicalPointing(frame, az_timestream='BoresightAz', el_timestream='BoresightEl', ra_timestream='BoresightRa', dec_timestream='BoresightDec', Telescope=<EarthLocation (710.21505704, -701.59071905, -6359587.23641261) m>)``




.. _spt3g.maps.coordsysmodules.AddLocalTransRotations:

**spt3g.maps.coordsysmodules.AddLocalTransRotations**

Creates the transform for boresight pointing for az el based maps.  This is
equivalent to FillCoordTransRotations with end_coord_sys in Local
coordinates.

Right now it's using the coordinate system where delta = -el because of
implementation details.  All of the maps generated with this will be upside
down in el.


*Definition:*
        ``AddLocalTransRotations(frame, az_key='RawBoresightAz', el_key='RawBoresightEl', out_key='RawAzElRotation')``




.. _spt3g.maps.coordsysmodules.EquatorialToGalacticTransRotations:

**spt3g.maps.coordsysmodules.EquatorialToGalacticTransRotations**

Takes a quaternion vector specifying the rotation to FK5 (Equatorial)
boresight and converts it into a rotation to Galactic J2000 boresight
coordinates.

Use this to convert the output of FillCoordTransRotations to Galactic
coordinates.


*Definition:*
        ``EquatorialToGalacticTransRotations(frame, eq_trans_key='OnlineRaDecRotation', out_key='OnlineGalacticRotation')``




.. _spt3g.maps.coordsysmodules.FillCoordTransRotations:

**spt3g.maps.coordsysmodules.FillCoordTransRotations**

Calculates the rotation quaternions that take the point (1,0,0) (so az=el=0)
in local coordinates to the coordinates specified by end_coord_sys and
stores them in transform_store_key.  This encodes the boresight pointing and
any rotations about this boresight pointing due to coordinate system
changes, az/el bearing tilt, etc.

*Arguments:*
	transform_store_key : string
	    The key where the output transformation quaternion will be stored.
	    If already present in the frame, this calculation will be skipped.
	end_coord_sys : MapCoordReference
	    If Local, the transformation is computed using the negative of the
	    detector delta angle.  Otherwise the detector angle is not inverted.
	do_bad_transform : bool
	    If end_coord_sys is not Local and this argument is True, the offset
	    keys are ignored and the coordinate transformation does not take
	    into account rotation about the boresight.
	bs_az_key, bs_el_key : string
	    Boresight coordinates in the local coordinate system.  If end_coord_sys
	    is Local, only these two keys are required.
	bs_ra_key, bs_dec_key : string
	    Boresight coordinates in the output coordinate system.  If
	    do_bad_transform is True, only these two keys and the previous two keys
	    are required.
	offset_az_key, offset_el_key, offset_ra_key, offset_dec_key : string
	    Local and output coordinates computed at a small offset from boresight.
	    These keys are required if do_bad_transform is False, and will be used
	    to account for any rotation about boresight in the coordinate
	    transformation.


*Definition:*
        ``FillCoordTransRotations(frame, transform_store_key='OnlineRaDecRotation', end_coord_sys=spt3g._libmaps.MapCoordReference.Equatorial, do_bad_transform=False, bs_az_key='RawBoresightAz', bs_el_key='RawBoresightEl', bs_ra_key='OnlineBoresightRa', bs_dec_key='OnlineBoresightDec', offset_az_key='OffsetBoresightAz', offset_el_key='OffsetBoresightEl', offset_ra_key='OnlineOffsetRa', offset_dec_key='OnlineOffsetDec')``




.. _spt3g.maps.fitsio.SaveMapFrame:

**spt3g.maps.fitsio.SaveMapFrame**

Save a map frame to a FITS file.  See ``save_skymap_fits`` for details.  The
map frame should contain T maps and (optionally) unpolarized weights, or T/Q/U
maps and (optionally) polarized weights to store in the output file.

*Arguments:*
	output_file : str or callable
	    Fits filename to which the map will be written.  Maybe a callable
	    function that takes a frame object as its sole input argument and
	    returns a string filename.
	hdr  : dict
	   If defined, extra keywords to be appened to the FITS header. The dict
	   can contain entries such as ``hdr['NEWKEY'] = 'New value'`` or
	   ``hdr['NEWKEY'] = ('New value', "Comment for New value")``.
	compress : str or bool
	    If defined, and if input maps are FlatSkyMap objects, store these in a
	    series of compressed image HDUs, one per map.  Otherwise, store input
	    maps in a series of standard ImageHDUs, which are readable with older
	    FITS readers (e.g. idlastro). If defined, the compression algorithm to
	    be used by the Astropy class astropy.io.fits.CompImageHDU.
	    Can be: 'RICE_1', 'RICE_ONE', 'PLIO_1', 'GZIP_1', 'GZIP_2' or
	    'HCOMPRESS_1'. Only GZIP_1 and GZIP_2 are lossless, although only
	    for integer data.
	quantize_level : float
	    Floating point quantization level for compression.  Higher values result
	    in more accurate floating point representation, but worse compression
	    ratio.  See the astropy FITS image documention for details:
	    https://docs.astropy.org/en/stable/io/fits/api/images.html
	overwrite : bool
	    If True, any existing file with the same name will be ovewritten.


*Definition:*
        ``SaveMapFrame(frame, output_file=None, hdr=None, compress=False, quantize_level=16.0, overwrite=False)``




.. _spt3g.maps.map_modules.ApplyWeights:

**spt3g.maps.map_modules.ApplyWeights**

Apply weights to the input maps.  The operation is performed in place to
minimize memory use.


*Definition:*
        ``ApplyWeights(frame)``




.. _spt3g.maps.map_modules.CoaddMaps:

**spt3g.maps.map_modules.CoaddMaps**

Coadd maps and weights, optionally collating by map Id.  This class can be
used as an argument to ``pipe.Add()`` as a standard pipeline module, or
instantiated as a standalone instance.  In the latter case, the object is
treated as a callable for input map frames, and the ``coadd_frame`` or
``coadd_frames`` attribute contains the running coadd(s).

The output coadd frames contain two additional keys: ``'InputMapIds'`` and
``'InputFiles'``, which are both lists of unique map Id's and filenames that
are associated with the frames that contribute to each coadd.  When one
coadd is added to another, these keys are updated recursively, so that the
resulting coadd includes the Id's and filenames that contributed to both
itself and the other coadd.  The list of filenames can be populated by
combining this module with a G3Reader whose ``track_filename`` option is set
to True; however, this feature is fragile and may not work as expected with
complex pipelines.

*Attributes:*
	coadd_frame : G3Frame
	    Output coadd map frame, also injected into the pipeline on
	    EndProcessing.  This attribute is only populated if the ``collate``
	    option is set to False.
	coadd_frames : dict of G3Frames
	    Output coadd map frames, keyed by input map Id.  Each frame is also
	    injected into the pipeline on EndProcessing.  This attribute is only
	    populated if the ``collate`` option is set to True.
	
*Methods:*
	get_map_id :
	    Takes a map frame as an argument and returns an identifier string for
	    the coadd to which it should be added, or None if the map should be
	    ignored.  This method can be modified by subclassing the CoaddMaps
	    module.
	
*Arguments:*
	map_ids : list of str
	    List of map Id's to include in the coadd(s).  If None, any maps in the
	    pipeline are included.  Otherwise, the output of the ``get_map_ids``
	    method is compared with this list, and the input frame is discarded if
	    no match is found.
	output_map_id : str
	    Id to assign to the output frame.  If ``collate`` is True, this argument
	    is required and treated as a prefix to which each input map Id is
	    appended.
	collate : bool
	    If True, coadd unique map Id's into separate output map frames.
	weighted : bool
	    If True (default), ensure that maps have had weights applied before
	    coadding.  Otherwise, coadd maps without checking the weights.
	ignore_missing_weights : bool
	    If False (default), a warning is issued when the frame contains weighted
	    Stokes maps without a weights map.  Set this option to True when feeding
	    single bolometer map frames with common weights through a pipeline.
	drop_input_frames : bool
	    If True, drop input map frames from the pipeline that are included in
	    any coadds.
	record_obs_id : bool
	    If True, include source name and observation ID info in the output coadd
	    frame ``InputMapIds`` key, along with the map ID for each input frame.
	    If False, only the map frame ID is included.

*Constructor:*
	``CoaddMaps(self, map_ids=None, output_map_id='Coadd', collate=False, weighted=True, ignore_missing_weights=False, drop_input_frames=False, record_obs_id=False)``




.. _spt3g.maps.map_modules.CompactMaps:

**spt3g.maps.map_modules.CompactMaps**

Compact all maps in a frame to their default sparse representation.
Optionally remove NaN values as well.  Removing NaN values will reduce
memory use, but will remove the distinction in unweighted (or
weight-removed) maps between unobserved regions and regions with zero
temperature.


*Definition:*
        ``CompactMaps(frame, zero_nans=False)``




.. _spt3g.maps.map_modules.ExtractMaps:

**spt3g.maps.map_modules.ExtractMaps**

Cache maps that come through the pipeline. Initialize an instance of this
module before adding to a pipeline..  Any maps that pass through the pipe
are stored in the .maps attribute of the object after the pipeline is run.

*Arguments:*
	map_id : string
	    If supplied, select only map frames that match this ID.
	copy : bool
	    If True, make a copy of the map on extraction.
	ignore_missing_weights : bool
	    If False (default), a warning is issued when the frame contains weighted
	    Stokes maps without a weights map.  Set this option to True when feeding
	    single bolometer map frames with common weights through a pipeline.

*Constructor:*
	``ExtractMaps(self, map_id=None, copy=False, ignore_missing_weights=False)``




.. _spt3g.maps.map_modules.FlattenPol:

**spt3g.maps.map_modules.FlattenPol**

For maps defined on the sphere the direction of the polarization angle is
is defined relative to the direction of North.  When making maps we follow
this definition.

For any flat sky estimators, the polarization angle is defined relative to
the vertical axis.  For some map projections the direction of north is not
the same as the vertical axis.  This function applies a rotation to the Q
and U values to switch the curved sky Q/U definition to the flat sky Q/U
definition.

If for whatever reason you want to reverse the process set the invert
argument to True.


*Definition:*
        ``FlattenPol(frame, invert=False)``




.. _spt3g.maps.map_modules.InjectMapStub:

**spt3g.maps.map_modules.InjectMapStub**

Inject a new map frame from a map stub.

*Arguments:*
	map_id : string
	    Id to assign to the new map frame
	map_stub : G3SkyMap instance
	    Map stub from which to clone the Stokes maps and weights.  If the
	    `weighted` attribute of the stub is True, the output frame will include
	    weights.  If the `pol_conv` attribute of the stub is not None, the
	    output frame will include Q and U maps (and polarized weights).

*Constructor:*
	``InjectMapStub(self, map_id, map_stub)``




.. _spt3g.maps.map_modules.InjectMaps:

**spt3g.maps.map_modules.InjectMaps**

Inject a set of maps into a new map frame.

*Arguments:*
	map_id : string
	    Id to assign to the new map frame
	maps_in : list or dict
	    Maps to add to the frame.  If a list, contains Stokes maps with valid
	    pol_type and weights.  If a dict, contains Stokes and weights maps keyed
	    by the standard map frame names.
	ignore_missing_weights [False] : bool
	    Skip warning about missing weights.  Useful for masks.

*Constructor:*
	``InjectMaps(self, map_id, maps_in, ignore_missing_weights=False)``




.. _spt3g.maps.map_modules.MakeMapsPolarized:

**spt3g.maps.map_modules.MakeMapsPolarized**

Converts individual unpolarized maps to polarized versions of the same map,
with the given polarization convention

This module is only a shim that creates null Q and U maps and populates
a properly invertible Wpol array from the TT Wunpol weights.


*Definition:*
        ``MakeMapsPolarized(frame, pol_conv=spt3g._libmaps.MapPolConv.IAU)``




.. _spt3g.maps.map_modules.MakeMapsUnpolarized:

**spt3g.maps.map_modules.MakeMapsUnpolarized**

Converts individual polarized maps to temperature-only versions of the same map.


*Definition:*
        ``MakeMapsUnpolarized(frame)``




.. _spt3g.maps.map_modules.RemoveWeights:

**spt3g.maps.map_modules.RemoveWeights**

Remove weights from input maps.  If zero_nans is `True`, empty pixels are
skipped and pixels with zero weight are set to 0 instead of NaN.  Operation
is performed in place to minimize memory use.


*Definition:*
        ``RemoveWeights(frame, zero_nans=False)``




.. _spt3g.maps.map_modules.ReplicateMaps:

**spt3g.maps.map_modules.ReplicateMaps**

Clone the input map frame with Id input_map_id into new stub frames, one for
each Id listed in output_map_ids.

*Arguments:*
	input_map_id : string
	    ID of the map frame to replicate.  The input frame is discarded after
	    replication.
	output_map_ids : list of strings
	    List of IDs to assign to replicated map frames.
	copy_weights : bool
	    If False, only the first output frame in the list includes a weights key
	    (Wpol or Wunpol).  If True, all output frames include a weights key.


*Definition:*
        ``ReplicateMaps(frame, input_map_id, output_map_ids, copy_weights=False)``




.. _spt3g.maps.map_modules.ReprojectMaps:

**spt3g.maps.map_modules.ReprojectMaps**

Reproject a map frame into a different projection.  Original data are
dropped and replaced by reprojected maps in the input frames.  Maps can be
changed between flat sky and healpix pixelizations, rotated between
Equatorial and Galactic coordinates, and/or change polarization convention
between COSMO and IAU, by setting the appropriate attributes of the input
and stub maps.  Attributes not defined in the stub map are assumed to be
that of the input map.  NB: coordinate rotation of polarized maps is not
currently implemented.

*Arguments:*
	map_stub : G3SkyMap object
	    A stub (empty) sky map object to be used to construct the output maps.
	    Can be a HealpixSkyMap or FlatSkyMap object.  Setting the ``pol_conv``
	    and/or ``coord_ref`` attributes to values that differ from those of the
	    input maps will result in output maps whose polarization convention
	    and/or reference coordinate system have been changed.
	rebin : int
	    If supplied and >1, subdivide the output pixel by n x n with each
	    sub-pixel taking on the input map values at pixel center (with interp or
	    nearest neighbor). The output pixel takes on the average of the
	    sub-pixel values.  In the case that the input map has higher resolution
	    than the output map (and that the input map is not low-pass filtered to
	    remove information above the Nyquist freq. of the output map pixel),
	    this reduces aliasing compared with direct sampling. But there would
	    still be aliased power from the input map from freq above the ouput map
	    pixel's Nyquist.
	interp : bool
	    If True, use bilinear interpolation to extract values from the input
	    map.  Otherwise, the nearest-neighbor value is used.

*Constructor:*
	``ReprojectMaps(self, map_stub=None, rebin=1, interp=False)``




.. _spt3g.maps.map_modules.SetPolConv:

**spt3g.maps.map_modules.SetPolConv**

Set or change the polarization convention of the input polarized map frame.
If switching between IAU and COSMO conventions, flip the sign of the U map
and the TU and QU weights.  Otherwise, just set the polarization convention
for all maps and weights.


*Definition:*
        ``SetPolConv(frame, pol_conv=spt3g._libmaps.MapPolConv.IAU)``




.. _spt3g.maps.map_modules.ValidateMaps:

**spt3g.maps.map_modules.ValidateMaps**

Validate that the input map frame has all the necessary keys.

If ignore_missing_weights is False (default), a warning is issued when the
frame contains weighted Stokes maps without a weights map.  Set this option
to True when feeding single bolometer map frames with common weights through
a pipeline.


*Definition:*
        ``ValidateMaps(frame, ignore_missing_weights=False)``




.. _spt3g.maps.quathelpers.AddTimingToPointingQuats:

**spt3g.maps.quathelpers.AddTimingToPointingQuats**

Transforms a quaternion pointing timestream <key> from a G3VectorQuat
to a G3TimestreamQuat by adding timing information extracted from some
other timestream-like object (scalar pointing timestreams, detector
timestreams etc.) specified by <timing_ref>. Because this operation is
backwards-compatible and involves no data loss, the transformation is
done in-place -- the previous data are deleted and replaced with the new
one.


*Definition:*
        ``AddTimingToPointingQuats(fr, key, timing_ref='RawBoresightAz')``



Functions in spt3g.maps
=======================
* spt3g.maps.azel.convert_azel_to_radec_

* spt3g.maps.azel.convert_gal_to_radec_

* spt3g.maps.azel.convert_radec_to_azel_

* spt3g.maps.azel.convert_radec_to_gal_

* spt3g.maps.fitsio.load_skymap_fits_

* spt3g.maps.fitsio.save_skymap_fits_

* spt3g.maps.map_modules.coadd_map_files_

* spt3g.maps.maputils.flatsky_to_healpix_

* spt3g.maps.maputils.healpix_to_flatsky_

* spt3g.maps.quathelpers.ang_to_quat_

* spt3g.maps.quathelpers.quat_to_ang_


.. _spt3g.maps.azel.convert_azel_to_radec:

**spt3g.maps.azel.convert_azel_to_radec**

Convert timestreams of local azimuth and elevation to right ascension and
declination.

*Arguments:*
	az, el : np.ndarray or G3Timestream
	    Array of local coordinates. If inputs are G3Timestream objects,
	    G3Timestreams are also returned.
	location : astropy.coordinates.EarthLocation instance
	    The telescope location on Earth.
	mjd : np.ndarray
	    An array of times for each az/el sample.  If input az and el
	    are not G3Timestreams, this argument is required.
	
*Returns:*
	ra, dec : np.ndarray or G3Timestream

*Definition:*
        ``convert_azel_to_radec(az, el, location=<EarthLocation (710.21505704, -701.59071905, -6359587.23641261) m>, mjd=None)``




.. _spt3g.maps.azel.convert_gal_to_radec:

**spt3g.maps.azel.convert_gal_to_radec**

Convert timestreams of Galactic longitude and latitude to right ascension
and declination.

*Arguments:*
	glon, glat : np.ndarray or G3Timestream
	    Array of Galactic sky coordinates. If inputs are G3Timestream
	    objects, G3Timestreams are also returned.
	
*Returns:*
	ra, dec : np.ndarray or G3Timestream

*Definition:*
        ``convert_gal_to_radec(glon, glat)``




.. _spt3g.maps.azel.convert_radec_to_azel:

**spt3g.maps.azel.convert_radec_to_azel**

Convert timestreams of right ascension and declination to local
azimuth and elevation.

*Arguments:*
	ra, dec : np.ndarray or G3Timestream
	    Array of Equatorial sky coordinates. If inputs are G3Timestream
	    objects, G3Timestreams are also returned.
	location : astropy.coordinates.EarthLocation instance
	    The telescope location on Earth.
	mjd : np.ndarray
	    An array of times for each ra/dec sample.  If input ra and dec
	    are not G3Timestreams, this argument is required.
	
*Returns:*
	az, el : np.ndarray or G3Timestream

*Definition:*
        ``convert_radec_to_azel(ra, dec, location=<EarthLocation (710.21505704, -701.59071905, -6359587.23641261) m>, mjd=None)``




.. _spt3g.maps.azel.convert_radec_to_gal:

**spt3g.maps.azel.convert_radec_to_gal**

Convert timestreams of right ascension and declination to Galactic
longitude and latitude.

*Arguments:*
	ra, dec : np.ndarray or G3Timestream
	    Array of Equatorial sky coordinates. If inputs are G3Timestream
	    objects, G3Timestreams are also returned.
	
*Returns:*
	glon, glat : np.ndarray or G3Timestream

*Definition:*
        ``convert_radec_to_gal(ra, dec)``




.. _spt3g.maps.fitsio.load_skymap_fits:

**spt3g.maps.fitsio.load_skymap_fits**

Load a fits file containing a sky map.

*Arguments:*
	filename : str
	    Path to fits file
	hdu : int, optional
	    If supplied, the data are extract from the given HDU index.
	keys : list of strings, optional
	    If supplied, return only these keys in the output dictionary.
	    Options are: T, Q, U, W.
	memmap : bool, optional
	    Argument passed to astropy.io.fits.open. If True, the map is not read
	    into memory, but only the required pixels are read when needed. Default:
	    False.
	apply_units : bool, optional
	    If True, and input maps have known units, multiply by the appropriate
	    conversion factor to return maps in G3Units.
	
*Returns:*
	a dictionary of maps keyed with e.g. 'T', 'Q', 'U' and 'W'.

*Definition:*
        ``load_skymap_fits(filename, hdu=None, keys=None, memmap=False, apply_units=False)``




.. _spt3g.maps.fitsio.save_skymap_fits:

**spt3g.maps.fitsio.save_skymap_fits**

Save G3 map objects to a fits file.

`FlatSkyMap` objects are stored in a series of (optionally compressed)
`ImageHDU` entries, in which each HDU contains the projection information in
its header in standard WCS format, along with the image data for a single
map (one of the Stokes maps or a weight map component).

`HealpixSkyMap` objects are stored in a `BinTableHDU` extension, which
contains the necessary header information for compatiblity with healpix map
readers (e.g. `healpix.read_map`), and a single table with one column per
Stokes map or weight map component.  Sparse maps are stored as cut-sky
pixel-indexed tables, while dense maps are stored with implicit indexing
over all pixels.  The former produces output that is equivalent to using
`healpy.write_map` with the `partial=True` option.

*Arguments:*
	filename : str
	    Path to output file.  Must not exist, unless overwrite is True.
	T[, Q, U] : FlatSkyMap or HealpixSkyMap
	    Maps to save
	W : G3SkyMapWeights
	    Weights to save with the maps
	overwrite : bool
	    If True, any existing file with the same name will be ovewritten.
	compress : str or bool
	    If defined, and if input maps are FlatSkyMap objects, store these in a
	    series of compressed image HDUs, one per map.  Otherwise, store input
	    maps in a series of standard ImageHDUs, which are readable with older
	    FITS readers (e.g. idlastro). If defined, the compression algorithm to
	    be used by the Astropy class astropy.io.fits.CompImageHDU.
	    Can be: 'RICE_1', 'RICE_ONE', 'PLIO_1', 'GZIP_1', 'GZIP_2' or
	    'HCOMPRESS_1'. Only GZIP_1 and GZIP_2 are lossless, although only
	    for integer data.
	quantize_level : float
	    Floating point quantization level for compression.  Higher values result
	    in more accurate floating point representation, but worse compression
	    ratio.  See the astropy FITS image documention for details:
	    https://docs.astropy.org/en/stable/io/fits/api/images.html
	hdr  : dict
	   If defined, extra keywords to be appened to the FITS header. The dict
	   can contain entries such as ``hdr['NEWKEY'] = 'New value'`` or
	   ``hdr['NEWKEY'] = ('New value', "Comment for New value")``.

*Definition:*
        ``save_skymap_fits(filename, T, Q=None, U=None, W=None, overwrite=False, compress=False, quantize_level=16.0, hdr=None)``




.. _spt3g.maps.map_modules.coadd_map_files:

**spt3g.maps.map_modules.coadd_map_files**

Coadd map files, optionally collating map Id's into separate frames.

*Arguments:*
	input_files : list of str
	    List of input files to feed through the pipeline.
	output_file : str
	    Output G3 filename.  If not supplied, the output frames are
	    returned without saving to disk.
	coadder : CoaddMaps instance
	    If set, use this instantiated module in the coadding pipeline.
	    In this case, all other keyword arguments below are ignored.
	map_ids : list of str
	    A list of map Id's to include in the coadd(s).
	output_map_id : str
	    Id to use for the output map frame.  If ``collate`` is True,
	    this is the prefix applied to each output frame, with the
	    input map Id appended to it.
	collate : bool
	    If True, coadd individual map Id's into separate map frames.
	    Otherwise, all map frames are coadded into one output frame.
	weighted : bool
	    If True, ensure that weights have been applied before coadding.
	    Otherwise, the input maps are coadded as they are.
	record_obs_id : bool
	    If True, include source name and observation ID info in the output coadd
	    frame ``InputMapIds`` key, along with the map ID for each input frame.
	    If False, only the map frame ID is included.
	
*Returns:*
	maps : G3Frame or dict of G3Frames
	    If ``collate`` is True, returns a dictionary of map frames
	    keyed by Id.  Otherwise, returns a single map frame.

*Definition:*
        ``coadd_map_files(input_files, output_file=None, coadder=None, map_ids=None, output_map_id='Coadd', collate=False, weighted=True, record_obs_id=False)``




.. _spt3g.maps.maputils.flatsky_to_healpix:

**spt3g.maps.maputils.flatsky_to_healpix**

Re-pixelize a map to Healpix from one of the flat projections.

*Parameters:*
	map_in: FlatSkyMap
	    The input map you want to reproject
	
	map_stub[None]: HealpixSkyMap
	    Stub output map object to be used to construct the output map.  If not
	    supplied, one will be constructed using the remaining keyword arguments.
	
	rebin[1]: int
	    If supplied and >1, subdivide the output pixel by n x n with each 
	    sub-pixel taking on the input map values at pixel center (with interp
	    or nearest neighbor). The output pixel takes on the average of the sub-pixel
	    values.
	    In the case that the input map has higher resolution than the output
	    map (and that the input map is not low-pass filtered to remove
	    information above the Nyquist freq. of the output map pixel), this
	    reduces aliasing compared with direct sampling. But there would still be
	    aliased power from the input map from freq above the ouput map pixel's
	    Nyquist. 
	
	interp[false]: bool
	    If True, use bilinear interpolation to extract values from the input
	    map.  Otherwise, the nearest-neighbor value is used.
	
	fullsky[false]: bool
	    If True a full-sky numpy array representation of the map is returned.
	    Otherwise, a HealpixSkyMap instance is returned, containing only the
	    pixels that overlap with the input map.
	
	All additional keyword arguments are passed to HealpixSkyMap to construct
	the output map object.  Required if `map_stub` is not supplied,
	otherwise ignored.
	
	Maps can be rotated between Equatorial and Galactic coordinates, and/or
	change polarization convention between COSMO and IAU, by setting the
	appropriate attributes of the input and output maps.  Attributes not defined
	in the output map are assumed to be that of the input map.
	
*Returns:*
	output_map: numpy array or HealpixSkyMap
	    The array containing the healpix map.  If `fullsky` is True, this is a
	    numpy array, otherwise a HealpixSkyMap instance.

*Definition:*
        ``flatsky_to_healpix(map_in, map_stub=None, rebin=1, interp=False, fullsky=False, **kwargs)``




.. _spt3g.maps.maputils.healpix_to_flatsky:

**spt3g.maps.maputils.healpix_to_flatsky**

Re-pixelize a map from Healpix to one of the flat sky projections.

*Parameters:*
	map_in: numpy array or HealpixSkyMap
	    The array containing the input healpix map to reproject.
	
	nest[False]: bool
	    Ordering of the healpix map, if the input is a numpy array.  Ring
	    ordering is assumed by default.
	
	map_stub[None]: FlatSkyMap
	    Stub output map object to be used to construct the output map.  If not
	    supplied, one will be constructed using the remaining keyword arguments.
	
	rebin[1]: int
	    If supplied and >1, subdivide the output pixel by n x n with each 
	    sub-pixel taking on the input map values at pixel center (with interp
	    or nearest neighbor). The output pixel takes on the average of the sub-pixel
	    values.
	    In the case that the input map has higher resolution than the output
	    map (and that the input map is not low-pass filtered to remove
	    information above the Nyquist freq. of the output map pixel), this
	    reduces aliasing compared with direct sampling. But there would still be
	    aliased power from the input map from freq above the ouput map pixel's
	    Nyquist. 
	
	interp[false]: bool
	    If True, use bilinear interpolation to extract values from the 4 closest
	    pixel centers of the healpix map. Otherwise, the nearest-neighbor value 
	    is used.
	
	All additional keyword arguments are passed to FlatSkyMap to construct the
	output map object.  Required if `map_stub` is not supplied, otherwise
	ignored.
	
	Maps can be rotated between Equatorial and Galactic coordinates, and/or
	change polarization convention between COSMO and IAU, by setting the
	appropriate attributes of the input and output maps.  Note that if the input
	map is a numpy array representation of a healpix map, the coordinate system
	and polarization convention are assumed to be that of the output map.
	Conversely, attributes not defined in the output map are assumed to be
	that of the input map.
	
*Returns:*
	output_map: FlatSkyMap
	    The reprojected map

*Definition:*
        ``healpix_to_flatsky(map_in, nest=False, map_stub=None, rebin=1, interp=False, **kwargs)``




.. _spt3g.maps.quathelpers.ang_to_quat:

**spt3g.maps.quathelpers.ang_to_quat**

Convert a set of angles (or vector of them) specified as a (longitude,
latitude) pair to a pointing quaternion (or vector of them). If start
and stop are defined, the return value for vectors will be a
G3TimestreamQuat with start and stop times set to the provided values.

*Definition:*
        ``ang_to_quat(alpha, delta, start=None, stop=None)``




.. _spt3g.maps.quathelpers.quat_to_ang:

**spt3g.maps.quathelpers.quat_to_ang**

Convert a pointing quaternion (or vector of them) to a set of angles (or
vector of them) specified as a (longitude, latitude) pair.

*Definition:*
        ``quat_to_ang(q)``




