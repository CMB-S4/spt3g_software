-----
dfmux
-----

dfmux contains code and dataclasses to collect and store data from the DfMux system, particulary focusing on the ICE system used for SPT3G and PB2. A general overview of how the modules here interact can be found in the :doc:`dataacquisition` section of the manual.


Frame Objects in spt3g.dfmux
============================
* spt3g.dfmux.DfMuxBoardSamples_

* spt3g.dfmux.DfMuxChannelMapping_

* spt3g.dfmux.DfMuxHousekeepingMap_

* spt3g.dfmux.DfMuxMetaSample_

* spt3g.dfmux.DfMuxSample_

* spt3g.dfmux.DfMuxWiringMap_

* spt3g.dfmux.HkBoardInfo_

* spt3g.dfmux.HkChannelInfo_

* spt3g.dfmux.HkMezzanineInfo_

* spt3g.dfmux.HkModuleInfo_


.. _spt3g.dfmux.DfMuxBoardSamples:

spt3g.dfmux.DfMuxBoardSamples
-----------------------------

Container structure for samples from modules on one board, mapping 0-indexed module and block IDs to a dfmux.DfMuxSample.

*Constructors:*
	``DfMuxBoardSamples()``
	
	``DfMuxBoardSamples( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``DfMuxBoardSamples( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``DfMuxBoardSamples()``



*Members:*

* **nmodules**: Number of modules expected to report from this board

* **nblocks**: Number of sub-module blocks expected to report from this board

* **nchannels**: Number of channels per block expected to report from this board


*Methods:*

.. _spt3g.dfmux.DfMuxBoardSamples.keys:

**spt3g.dfmux.DfMuxBoardSamples.keys**

``keys( (DfMuxBoardSamples)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.dfmux.DfMuxBoardSamples.has_key:

**spt3g.dfmux.DfMuxBoardSamples.has_key**

``has_key( (DfMuxBoardSamples)arg1, (int)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.dfmux.DfMuxBoardSamples.values:

**spt3g.dfmux.DfMuxBoardSamples.values**

``values( (DfMuxBoardSamples)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.dfmux.DfMuxBoardSamples.items:

**spt3g.dfmux.DfMuxBoardSamples.items**

``items( (DfMuxBoardSamples)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.dfmux.DfMuxBoardSamples.clear:

**spt3g.dfmux.DfMuxBoardSamples.clear**

``clear( (DfMuxBoardSamples)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.dfmux.DfMuxBoardSamples.copy:

**spt3g.dfmux.DfMuxBoardSamples.copy**

``copy( (DfMuxBoardSamples)arg1) -> DfMuxBoardSamples :``
    D.copy() -> a shallow copy of D

.. _spt3g.dfmux.DfMuxBoardSamples.get:

**spt3g.dfmux.DfMuxBoardSamples.get**

``get( (DfMuxBoardSamples)arg1, (int)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.dfmux.DfMuxBoardSamples.pop:

**spt3g.dfmux.DfMuxBoardSamples.pop**

``pop( (DfMuxBoardSamples)arg1, (int)arg2) -> object``

``pop( (DfMuxBoardSamples)arg1, (int)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.dfmux.DfMuxBoardSamples.popitem:

**spt3g.dfmux.DfMuxBoardSamples.popitem**

``popitem( (DfMuxBoardSamples)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.dfmux.DfMuxBoardSamples.update:

**spt3g.dfmux.DfMuxBoardSamples.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.dfmux.DfMuxBoardSamples.iteritems:

**spt3g.dfmux.DfMuxBoardSamples.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.dfmux.DfMuxBoardSamples.iterkeys:

**spt3g.dfmux.DfMuxBoardSamples.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.dfmux.DfMuxBoardSamples.itervalues:

**spt3g.dfmux.DfMuxBoardSamples.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D

.. _spt3g.dfmux.DfMuxBoardSamples.Complete:

**spt3g.dfmux.DfMuxBoardSamples.Complete**

``Complete( (DfMuxBoardSamples)arg1) -> bool :``
    True if this structure contains data from all expected modules and blocks



.. _spt3g.dfmux.DfMuxChannelMapping:

spt3g.dfmux.DfMuxChannelMapping
-------------------------------

Bolometer wiring information. Module and channel IDs are stored zero-indexed, but be aware that they often printed one-indexed for compatibility with pydfmux.

*Constructors:*
	``DfMuxChannelMapping()``
	
	``DfMuxChannelMapping( (DfMuxChannelMapping)arg2)``



*Members:*

* **board_ip**: IP Address of the board, encoded as an int using struct

* **board_serial**: Serial number of the readout board to which this channel is attached.

* **board_slot**: Crate slot of the board to which this channel is attached or -1 if the board is not in a crate.

* **crate_serial**: Serial number of the crate in which the readout board is housed or -1 if the board is not in a crate.

* **module**: 0-indexed module/SQUID ID of the channel

* **channel**: 0-indexed channel number on the parent module/SQUID



.. _spt3g.dfmux.DfMuxHousekeepingMap:

spt3g.dfmux.DfMuxHousekeepingMap
--------------------------------

Container structure for housekeeping data from all DfMux boards, indexed by board serial number.

*Constructors:*
	``DfMuxHousekeepingMap()``
	
	``DfMuxHousekeepingMap( (DfMuxHousekeepingMap)arg2)``
	
	``DfMuxHousekeepingMap( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``DfMuxHousekeepingMap( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``DfMuxHousekeepingMap()``



*Methods:*

.. _spt3g.dfmux.DfMuxHousekeepingMap.keys:

**spt3g.dfmux.DfMuxHousekeepingMap.keys**

``keys( (DfMuxHousekeepingMap)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.dfmux.DfMuxHousekeepingMap.has_key:

**spt3g.dfmux.DfMuxHousekeepingMap.has_key**

``has_key( (DfMuxHousekeepingMap)arg1, (int)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.dfmux.DfMuxHousekeepingMap.values:

**spt3g.dfmux.DfMuxHousekeepingMap.values**

``values( (DfMuxHousekeepingMap)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.dfmux.DfMuxHousekeepingMap.items:

**spt3g.dfmux.DfMuxHousekeepingMap.items**

``items( (DfMuxHousekeepingMap)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.dfmux.DfMuxHousekeepingMap.clear:

**spt3g.dfmux.DfMuxHousekeepingMap.clear**

``clear( (DfMuxHousekeepingMap)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.dfmux.DfMuxHousekeepingMap.copy:

**spt3g.dfmux.DfMuxHousekeepingMap.copy**

``copy( (DfMuxHousekeepingMap)arg1) -> DfMuxHousekeepingMap :``
    D.copy() -> a shallow copy of D

.. _spt3g.dfmux.DfMuxHousekeepingMap.get:

**spt3g.dfmux.DfMuxHousekeepingMap.get**

``get( (DfMuxHousekeepingMap)arg1, (int)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.dfmux.DfMuxHousekeepingMap.pop:

**spt3g.dfmux.DfMuxHousekeepingMap.pop**

``pop( (DfMuxHousekeepingMap)arg1, (int)arg2) -> object``

``pop( (DfMuxHousekeepingMap)arg1, (int)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.dfmux.DfMuxHousekeepingMap.popitem:

**spt3g.dfmux.DfMuxHousekeepingMap.popitem**

``popitem( (DfMuxHousekeepingMap)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.dfmux.DfMuxHousekeepingMap.update:

**spt3g.dfmux.DfMuxHousekeepingMap.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.dfmux.DfMuxHousekeepingMap.iteritems:

**spt3g.dfmux.DfMuxHousekeepingMap.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.dfmux.DfMuxHousekeepingMap.iterkeys:

**spt3g.dfmux.DfMuxHousekeepingMap.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.dfmux.DfMuxHousekeepingMap.itervalues:

**spt3g.dfmux.DfMuxHousekeepingMap.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.dfmux.DfMuxMetaSample:

spt3g.dfmux.DfMuxMetaSample
---------------------------

Container structure for coincident samples from all boards. Individual board data, stored in dfmux.DfMuxBoardSamples classes, is contained indexed by board serial number.

*Constructors:*
	``DfMuxMetaSample()``
	
	``DfMuxMetaSample( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``DfMuxMetaSample( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``DfMuxMetaSample()``



*Methods:*

.. _spt3g.dfmux.DfMuxMetaSample.keys:

**spt3g.dfmux.DfMuxMetaSample.keys**

``keys( (DfMuxMetaSample)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.dfmux.DfMuxMetaSample.has_key:

**spt3g.dfmux.DfMuxMetaSample.has_key**

``has_key( (DfMuxMetaSample)arg1, (int)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.dfmux.DfMuxMetaSample.values:

**spt3g.dfmux.DfMuxMetaSample.values**

``values( (DfMuxMetaSample)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.dfmux.DfMuxMetaSample.items:

**spt3g.dfmux.DfMuxMetaSample.items**

``items( (DfMuxMetaSample)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.dfmux.DfMuxMetaSample.clear:

**spt3g.dfmux.DfMuxMetaSample.clear**

``clear( (DfMuxMetaSample)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.dfmux.DfMuxMetaSample.copy:

**spt3g.dfmux.DfMuxMetaSample.copy**

``copy( (DfMuxMetaSample)arg1) -> DfMuxMetaSample :``
    D.copy() -> a shallow copy of D

.. _spt3g.dfmux.DfMuxMetaSample.get:

**spt3g.dfmux.DfMuxMetaSample.get**

``get( (DfMuxMetaSample)arg1, (int)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.dfmux.DfMuxMetaSample.pop:

**spt3g.dfmux.DfMuxMetaSample.pop**

``pop( (DfMuxMetaSample)arg1, (int)arg2) -> object``

``pop( (DfMuxMetaSample)arg1, (int)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.dfmux.DfMuxMetaSample.popitem:

**spt3g.dfmux.DfMuxMetaSample.popitem**

``popitem( (DfMuxMetaSample)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.dfmux.DfMuxMetaSample.update:

**spt3g.dfmux.DfMuxMetaSample.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.dfmux.DfMuxMetaSample.iteritems:

**spt3g.dfmux.DfMuxMetaSample.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.dfmux.DfMuxMetaSample.iterkeys:

**spt3g.dfmux.DfMuxMetaSample.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.dfmux.DfMuxMetaSample.itervalues:

**spt3g.dfmux.DfMuxMetaSample.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.dfmux.DfMuxSample:

spt3g.dfmux.DfMuxSample
-----------------------

Samples from all channels on one readout module, stored with I and Q interleaved, such that the first element is channel 1 I, followed by channel 1 Q, followed by channel 2 I, etc.

*Constructors:*
	``DfMuxSample( (int)time, (int)nsamples)``



*Members:*

* **Timestamp**: No Doc (Shame!)



.. _spt3g.dfmux.DfMuxWiringMap:

spt3g.dfmux.DfMuxWiringMap
--------------------------

Mapping from logical detector ID string (same as used in timestreams) to wiring information (the board, module, and channel to which a given detector is connected)

*Constructors:*
	``DfMuxWiringMap()``
	
	``DfMuxWiringMap( (DfMuxWiringMap)arg2)``
	
	``DfMuxWiringMap( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``DfMuxWiringMap( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``DfMuxWiringMap()``



*Methods:*

.. _spt3g.dfmux.DfMuxWiringMap.keys:

**spt3g.dfmux.DfMuxWiringMap.keys**

``keys( (DfMuxWiringMap)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.dfmux.DfMuxWiringMap.has_key:

**spt3g.dfmux.DfMuxWiringMap.has_key**

``has_key( (DfMuxWiringMap)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.dfmux.DfMuxWiringMap.values:

**spt3g.dfmux.DfMuxWiringMap.values**

``values( (DfMuxWiringMap)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.dfmux.DfMuxWiringMap.items:

**spt3g.dfmux.DfMuxWiringMap.items**

``items( (DfMuxWiringMap)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.dfmux.DfMuxWiringMap.clear:

**spt3g.dfmux.DfMuxWiringMap.clear**

``clear( (DfMuxWiringMap)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.dfmux.DfMuxWiringMap.copy:

**spt3g.dfmux.DfMuxWiringMap.copy**

``copy( (DfMuxWiringMap)arg1) -> DfMuxWiringMap :``
    D.copy() -> a shallow copy of D

.. _spt3g.dfmux.DfMuxWiringMap.get:

**spt3g.dfmux.DfMuxWiringMap.get**

``get( (DfMuxWiringMap)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.dfmux.DfMuxWiringMap.pop:

**spt3g.dfmux.DfMuxWiringMap.pop**

``pop( (DfMuxWiringMap)arg1, (str)arg2) -> object``

``pop( (DfMuxWiringMap)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.dfmux.DfMuxWiringMap.popitem:

**spt3g.dfmux.DfMuxWiringMap.popitem**

``popitem( (DfMuxWiringMap)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.dfmux.DfMuxWiringMap.update:

**spt3g.dfmux.DfMuxWiringMap.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.dfmux.DfMuxWiringMap.iteritems:

**spt3g.dfmux.DfMuxWiringMap.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.dfmux.DfMuxWiringMap.iterkeys:

**spt3g.dfmux.DfMuxWiringMap.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.dfmux.DfMuxWiringMap.itervalues:

**spt3g.dfmux.DfMuxWiringMap.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.dfmux.HkBoardInfo:

spt3g.dfmux.HkBoardInfo
-----------------------

Mux board status. Includes both configuration and sensor readings for board generic quantities and a list of quantities for the mezzanines.

*Constructors:*
	``HkBoardInfo()``
	
	``HkBoardInfo( (HkBoardInfo)arg2)``



*Members:*

* **timestamp**: Time at which housekeeping data collected

* **timestamp_port**: Source of timestamps on board

* **serial**: Board serial number

* **fir_stage**: Sample rate encoded as the "FIR Stage". Smaller numbers are faster and grow by factors of two with each decrement

* **is128x**: Boolean for whether 128x firmware is running

* **firmware_version**: Firmware version

* **firmware_name**: Firmware name

* **currents**: Dictionary of data from on-board current sensors

* **voltages**: Dictionary of data from on-board voltage sensors

* **temperatures**: Dictionary of data from on-board temperature sensors (C)

* **mezz**: 1-indexed mapping from mezzanine ID to mezzanine-specific data



.. _spt3g.dfmux.HkChannelInfo:

spt3g.dfmux.HkChannelInfo
-------------------------

Mux channel status (configuration and sensors). Usually a part of an HkModuleInfo.

*Constructors:*
	``HkChannelInfo()``
	
	``HkChannelInfo( (HkChannelInfo)arg2)``



*Members:*

* **channel_number**: 1-indexed channel number.

* **carrier_amplitude**: Carrier amplitude in normalized units (0-1).

* **carrier_frequency**: Carrier frequency in standard frequency units

* **dan_accumulator_enable**: True if DAN accumulator enabled

* **dan_feedback_enable**: True if DAN control of the nuller is enabled

* **dan_streaming_enable**: True if streamer packets are from DAN rather than demod

* **dan_gain**: DAN gain in board units

* **demod_frequency**: Frequency of the demodulator in standard frequency units.

* **nuller_amplitude**: Nuller amplitude in normalized units (0-1)

* **dan_railed**: True if DAN has railed.

* **state**: String code ("latched", "tuned" etc.) describing the state of this detector stored by the control software

* **rlatched**: Resistance of the detector when latched in standard impedance units as stored by the control software tuning script.

* **rnormal**: Resistance of the detector when normal in standard impedance units as stored by the control software tuning script.

* **rfrac_achieved**: Achieved resistance of the detector when tuned as a fraction of rnormal, as stored by the control software tuning script.

* **loopgain**: Measured loopgain of the detector as stored by the control software tuning script.

* **carrier_phase**: Carrier phase in standard angle units (mkid only)

* **nuller_phase**: Nuller phase in standard angle units (mkid only)

* **demod_phase**: Demodulator phase in standard angle units (mkid only)



.. _spt3g.dfmux.HkMezzanineInfo:

spt3g.dfmux.HkMezzanineInfo
---------------------------

Mux mezzanine status

*Constructors:*
	``HkMezzanineInfo()``
	
	``HkMezzanineInfo( (HkMezzanineInfo)arg2)``



*Members:*

* **power**: True if on

* **present**: True if exists

* **serial**: Mezzanine serial number

* **part_number**: Mezzanine part ID (usually "MGMEZZ04")

* **revision**: Mezzanine revision number

* **currents**: Dictionary of measured currents on mezzanine

* **voltages**: Dictionary of measured voltages on mezzanine

* **modules**: 1-indexed list of housekeeping data from readout modules on this mezzanine

* **temperature**: Mezzanine temperature (C)

* **squid_controller_temperature**: Measured temperature of SQUID controller board (C)

* **squid_controller_power**: True if SQUID controller board powered up

* **squid_heater**: Power level of SQUID header control



.. _spt3g.dfmux.HkModuleInfo:

spt3g.dfmux.HkModuleInfo
------------------------

Mux module status

*Constructors:*
	``HkModuleInfo()``
	
	``HkModuleInfo( (HkModuleInfo)arg2)``



*Members:*

* **module_number**: 1-indexed module number on this mezzanine

* **carrier_gain**: Carrier gain code, in board-specific units

* **nuller_gain**: Nuller gain code, in board-specific units

* **demod_gain**: Demod gain code, in board-specific units

* **carrier_railed**: True if carrier has recently hit a DAC rail

* **nuller_railed**: True if nuller has recently hit a DAC rail

* **demod_railed**: True if demod input has recently hit one of the ADC rails

* **squid_flux_bias**: Flux bias, in board-specific units (XXX)

* **squid_current_bias**: SQUID current bias, in board-specific units (XXX)

* **squid_stage1_offset**: Offset voltage applied to SQUID output before first-stage amp

* **squid_p2p**: Peak-to-peak voltage difference in V-Phi curve stored by tuning script

* **squid_transimpedance**: Measured SQUID transimpedance, in resistance units

* **squid_state**: Descriptive string (e.g. "Tuned") stored by control system tuning script to describe SQUID state

* **squid_feedback**: SQUID feedback mechanism employed

* **nco_frequency**: NCO frequency in standard frequency units (mkid only)

* **routing_type**: Whether DAC are routed directly to ADCs or to the cryostat

* **channels**: Mapping from 1-indexed channel numbers to channel housekeeping data


Modules in spt3g.dfmux
======================
* spt3g.dfmux.DfMuxBuilder_

* spt3g.dfmux.DfMuxCollator_

* spt3g.dfmux.HardwareMapTools.DfmlHardwareMapInjector_

* spt3g.dfmux.HardwareMapTools.GenerateFakeHardwareMap_

* spt3g.dfmux.HardwareMapTools.PyDfMuxBolometerPropertiesInjector_

* spt3g.dfmux.HardwareMapTools.PyDfMuxWiringMapInjector_

* spt3g.dfmux.Housekeeping.HousekeepingConsumer_

* spt3g.dfmux.Housekeeping.PeriodicHousekeepingCollector_

* spt3g.dfmux.LegacyHousekeeping.LegacyHousekeepingConsumer_

* spt3g.dfmux.NetCDFDump_

* spt3g.dfmux.ScanTools.FixedLengthScans_

* spt3g.dfmux.unittransforms.ConvertTimestreamUnits_


.. _spt3g.dfmux.DfMuxBuilder:

**spt3g.dfmux.DfMuxBuilder**

Processing module for data from DfMux boards. Reads data from boards data acquisition boards, requiring that data from all be timestamped to within collation_tolerance (default 10 microseconds) to be considered part of a single sample. If boards is an integer, listens for that number. If a list of integers, DfMuxBuilder will filter for only boards with serial numbers in the list.


*Constructors:*
	``DfMuxBuilder( (int)boards [, (int)collation_tolerance])``
	
	``DfMuxBuilder( (IntVector)boards [, (int)collation_tolerance])``




.. _spt3g.dfmux.DfMuxCollator:

**spt3g.dfmux.DfMuxCollator**

Collects DfMux timepoints into scan frames using a provided wiring map. Scan frames are created when an empty Scan frame appears in the data stream. This frame will contain all subsequent timepoints until either the next Scan frame is detected or the stream ends. In addition to dfmux timestreams, any scalar floating numbers that recur in every input Timepoint frame will be combined into a G3Timestream of the same name stored in the output scan frame.


*Constructors:*
	``DfMuxCollator( [ (bool)flac_compress [, (bool)drop_timepoints [, (bool)record_sampletimes]]])``




.. _spt3g.dfmux.HardwareMapTools.DfmlHardwareMapInjector:

**spt3g.dfmux.HardwareMapTools.DfmlHardwareMapInjector**


*Constructor:*
	``DfmlHardwareMapInjector(dfml_hwm)``




.. _spt3g.dfmux.HardwareMapTools.GenerateFakeHardwareMap:

**spt3g.dfmux.HardwareMapTools.GenerateFakeHardwareMap**

Inserts a fake hardware map into the data stream. Takes a wiring frame as an argument to the constructor, which it will inject before any other frames.

*Constructor:*
	``GenerateFakeHardwareMap(frame)``




.. _spt3g.dfmux.HardwareMapTools.PyDfMuxBolometerPropertiesInjector:

**spt3g.dfmux.HardwareMapTools.PyDfMuxBolometerPropertiesInjector**

Insert a calibration frame following any wiring frame containing a
BolometerPropertiesMap named "NominalBolometerProperties" that has
the properties of each bolometer as defined by the given pydfmux 
hardware map.


*Definition:*
        ``PyDfMuxBolometerPropertiesInjector(frame, pydfmux_hwm=None, angle_per_mm=7.305948248848263e-05)``




.. _spt3g.dfmux.HardwareMapTools.PyDfMuxWiringMapInjector:

**spt3g.dfmux.HardwareMapTools.PyDfMuxWiringMapInjector**

Insert a wiring map derived from a pydfmux hardware map into the data
stream ahead of what would otherwise be the first frame.

Optionally filter for detectors described by the mask in <pathstring>
(see pydfmux documentation for hwm.channel_maps_from_pstring()) and
detectors in one of the states identified by the state argument.

*Constructor:*
	``PyDfMuxWiringMapInjector(pydfmux_hwm, pathstring=None, state=[])``




.. _spt3g.dfmux.Housekeeping.HousekeepingConsumer:

**spt3g.dfmux.Housekeeping.HousekeepingConsumer**

Collect housekeeping data from the mux boards defined in the wiring map.
Will add a key called 'DfMuxHousekeeping' to any housekeeping frame that
goes by containing the data as of the arrival of the housekeeping frame.
Use in conjunction with a dfmux.PeriodicHousekeepingCollector to get
data at fixed intervals.

Also emits a Wiring frame from the housekeeping data.  This requires a
recent (as of November 2018) version of pydfmux in order to read mapped
channel names from each board.  If ignore_wiring=False, assumes that
the wiring map is handled by a separate process.

If collecting real-time data, you may want to set subprocess=True when
adding this module.

*Constructor:*
	``HousekeepingConsumer(ignore_wiring=False)``




.. _spt3g.dfmux.Housekeeping.PeriodicHousekeepingCollector:

**spt3g.dfmux.Housekeeping.PeriodicHousekeepingCollector**

Inserts housekeeping frames every N timepoints.

*Constructor:*
	``PeriodicHousekeepingCollector(N=15200)``




.. _spt3g.dfmux.LegacyHousekeeping.LegacyHousekeepingConsumer:

**spt3g.dfmux.LegacyHousekeeping.LegacyHousekeepingConsumer**

Collect housekeeping data from the legacy (i.e. SPTpol-ish) mux boards
defined in the wiring map. Will add a key called 'DfMuxHousekeeping' to
any housekeeping frame that goes by containing the data as of the arrival
of the housekeeping frame. Use in conjunction with a
dfmux.PeriodicHousekeepingCollector to get data at fixed intervals.

If collecting real-time data, you may want to set subprocess=True when
adding this module.

*Constructor:*
	``LegacyHousekeepingConsumer(self)``




.. _spt3g.dfmux.NetCDFDump:

**spt3g.dfmux.NetCDFDump**

Writes DfMux streamer data to a NetCDF file


*Constructors:*
	``NetCDFDump( (str)filename)``




.. _spt3g.dfmux.ScanTools.FixedLengthScans:

**spt3g.dfmux.ScanTools.FixedLengthScans**

Makes scans of length N timepoints.

*Constructor:*
	``FixedLengthScans(N=1000)``




.. _spt3g.dfmux.unittransforms.ConvertTimestreamUnits:

**spt3g.dfmux.unittransforms.ConvertTimestreamUnits**

Changes timestream units from one set of units (e.g. ADC counts) to
another (e.g. Power). Currents and power are time averaged quantities
(i.e. currents give RMS values).

Note that this does not handle conversions to on-sky quantities (e.g. K_cmb)

*Constructor:*
	``ConvertTimestreamUnits(Input='RawTimestreams', Output='CalTimestreams', Units=spt3g.core.G3TimestreamUnits.Power, SkipUncalibratable=False, KeepConversionsForObservation=True)``

*Constructor:*
	Copy data in the timestream map Input to the timestream map Output,
	converting the units from whatever they were to those specified by
	Units.
	
	If SkipUncalibratable is true, copy timestreams for which the
	unit conversions could not be evaluated into the output timestream
	in their original units. If false, throws an exception if this occurs.
	
	If KeepConversionsForObservation is True (default), conversion factors
	will only be evaluated once per observation. Note that this will cause
	the wrong conversions to be applied if any parameters of the mux system
	are modified during the observation but will substantially increase
	performance.



Functions in spt3g.dfmux
========================
* spt3g.dfmux.HardwareMapTools.PathStringForBolo_

* spt3g.dfmux.Housekeeping.HousekeepingForBolo_

* spt3g.dfmux.unittransforms.get_timestream_unit_conversion_


.. _spt3g.dfmux.HardwareMapTools.PathStringForBolo:

**spt3g.dfmux.HardwareMapTools.PathStringForBolo**

Obtain the channel pathstring for a bolometer named "bolo"
using the passed wiring map.

*Definition:*
        ``PathStringForBolo(wiringmap, bolo)``




.. _spt3g.dfmux.Housekeeping.HousekeepingForBolo:

**spt3g.dfmux.Housekeeping.HousekeepingForBolo**

Obtain the channel housekeeping information for a bolometer named "bolo"
using the passed housekeeping and wiring maps.

If all_hk is True, returns a tuple of the (board, mezz, module, channel)
HK data instead of just the channel.

*Definition:*
        ``HousekeepingForBolo(hkmap, wiringmap, bolo, all_hk=False)``




.. _spt3g.dfmux.unittransforms.get_timestream_unit_conversion:

**spt3g.dfmux.unittransforms.get_timestream_unit_conversion**

Return the scalar conversion factor to move timestream data from a
given system of units (Power, Resistance, Current, Counts) to another one.
Requires a wiring map and recent housekeeping data.
Returned quantities are RMS for currents and time-averaged for power.

Note that this does not handle conversions to on-sky quantities (e.g. K_cmb)

*Definition:*
        ``get_timestream_unit_conversion(from_units, to_units, bolo, wiringmap=None, hkmap=None, system=None, tf=None)``




