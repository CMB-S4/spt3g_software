-----
dfmux
-----

dfmux contains code and dataclasses to collect and store data from the DfMux system, particulary focusing on the ICE system used for SPT3G and PB2. A general overview of how the modules here interact can be found in the :doc:`dataacquisition` section of the manual.


Modules in spt3g.dfmux
======================
* spt3g.dfmux.HardwareMapTools.DfmlHardwareMapInjector_

* spt3g.dfmux.HardwareMapTools.GenerateFakeHardwareMap_

* spt3g.dfmux.HardwareMapTools.PyDfMuxBolometerPropertiesInjector_

* spt3g.dfmux.HardwareMapTools.PyDfMuxWiringMapInjector_

* spt3g.dfmux.Housekeeping.HousekeepingConsumer_

* spt3g.dfmux.Housekeeping.PeriodicHousekeepingCollector_

* spt3g.dfmux.LegacyHousekeeping.LegacyHousekeepingConsumer_

* spt3g.dfmux.ScanTools.FixedLengthScans_

* spt3g.dfmux.unittransforms.ConvertTimestreamUnits_


.. _spt3g.dfmux.HardwareMapTools.DfmlHardwareMapInjector:

**spt3g.dfmux.HardwareMapTools.DfmlHardwareMapInjector**


*Constructor:*
	``DfmlHardwareMapInjector(self, dfml_hwm)``




.. _spt3g.dfmux.HardwareMapTools.GenerateFakeHardwareMap:

**spt3g.dfmux.HardwareMapTools.GenerateFakeHardwareMap**

Inserts a fake hardware map into the data stream. Takes a wiring frame as an argument to the constructor, which it will inject before any other frames.

*Constructor:*
	``GenerateFakeHardwareMap(self, frame)``




.. _spt3g.dfmux.HardwareMapTools.PyDfMuxBolometerPropertiesInjector:

**spt3g.dfmux.HardwareMapTools.PyDfMuxBolometerPropertiesInjector**

Insert a calibration frame following any wiring frame containing a
BolometerPropertiesMap named "NominalBolometerProperties" that has
the properties of each bolometer as defined by the given pydfmux 
hardware map.


*Definition:*
        ``PyDfMuxBolometerPropertiesInjector(frame, pydfmux_hwm=None, angle_per_mm=7.305948248848263e-05)``




.. _spt3g.dfmux.HardwareMapTools.PyDfMuxWiringMapInjector:

**spt3g.dfmux.HardwareMapTools.PyDfMuxWiringMapInjector**

Insert a wiring map derived from a pydfmux hardware map into the data
stream ahead of what would otherwise be the first frame.

Optionally filter for detectors described by the mask in <pathstring>
(see pydfmux documentation for hwm.channel_maps_from_pstring()) and
detectors in one of the states identified by the state argument.

*Constructor:*
	``PyDfMuxWiringMapInjector(self, pydfmux_hwm, pathstring=None, state=[])``




.. _spt3g.dfmux.Housekeeping.HousekeepingConsumer:

**spt3g.dfmux.Housekeeping.HousekeepingConsumer**

Collect housekeeping data from the mux boards defined in the wiring map.
Will add a key called 'DfMuxHousekeeping' to any housekeeping frame that
goes by containing the data as of the arrival of the housekeeping frame.
Use in conjunction with a dfmux.PeriodicHousekeepingCollector to get
data at fixed intervals.

Also emits a Wiring frame from the housekeeping data.  This requires a
recent (as of November 2018) version of pydfmux in order to read mapped
channel names from each board.  If ignore_wiring=False, assumes that
the wiring map is handled by a separate process.

If collecting real-time data, you may want to set subprocess=True when
adding this module.

*Constructor:*
	``HousekeepingConsumer(self, ignore_wiring=False)``




.. _spt3g.dfmux.Housekeeping.PeriodicHousekeepingCollector:

**spt3g.dfmux.Housekeeping.PeriodicHousekeepingCollector**

Inserts housekeeping frames every N timepoints.

*Constructor:*
	``PeriodicHousekeepingCollector(self, N=15200)``




.. _spt3g.dfmux.LegacyHousekeeping.LegacyHousekeepingConsumer:

**spt3g.dfmux.LegacyHousekeeping.LegacyHousekeepingConsumer**

Collect housekeeping data from the legacy (i.e. SPTpol-ish) mux boards
defined in the wiring map. Will add a key called 'DfMuxHousekeeping' to
any housekeeping frame that goes by containing the data as of the arrival
of the housekeeping frame. Use in conjunction with a
dfmux.PeriodicHousekeepingCollector to get data at fixed intervals.

If collecting real-time data, you may want to set subprocess=True when
adding this module.

*Constructor:*
	``LegacyHousekeepingConsumer(self)``




.. _spt3g.dfmux.ScanTools.FixedLengthScans:

**spt3g.dfmux.ScanTools.FixedLengthScans**

Makes scans of length N timepoints.

*Constructor:*
	``FixedLengthScans(self, N=1000)``




.. _spt3g.dfmux.unittransforms.ConvertTimestreamUnits:

**spt3g.dfmux.unittransforms.ConvertTimestreamUnits**

Changes timestream units from one set of units (e.g. ADC counts) to
another (e.g. Power). Currents and power are time averaged quantities
(i.e. currents give RMS values).

Note that this does not handle conversions to on-sky quantities (e.g. K_cmb)

*Constructor:*
	``ConvertTimestreamUnits(self, Input='RawTimestreams', Output='CalTimestreams', Units=spt3g._libcore.G3TimestreamUnits.Power, SkipUncalibratable=False, KeepConversionsForObservation=True)``


*Constructor:*
	Copy data in the timestream map Input to the timestream map Output,
	converting the units from whatever they were to those specified by
	Units.
	
	If SkipUncalibratable is true, copy timestreams for which the
	unit conversions could not be evaluated into the output timestream
	in their original units. If false, throws an exception if this occurs.
	
	If KeepConversionsForObservation is True (default), conversion factors
	will only be evaluated once per observation. Note that this will cause
	the wrong conversions to be applied if any parameters of the mux system
	are modified during the observation but will substantially increase
	performance.



Functions in spt3g.dfmux
========================
* spt3g.dfmux.HardwareMapTools.PathStringForBolo_

* spt3g.dfmux.Housekeeping.HousekeepingForBolo_

* spt3g.dfmux.unittransforms.get_timestream_unit_conversion_


.. _spt3g.dfmux.HardwareMapTools.PathStringForBolo:

**spt3g.dfmux.HardwareMapTools.PathStringForBolo**

Obtain the channel pathstring for a bolometer named "bolo"
using the passed wiring map.

*Definition:*
        ``PathStringForBolo(wiringmap, bolo)``




.. _spt3g.dfmux.Housekeeping.HousekeepingForBolo:

**spt3g.dfmux.Housekeeping.HousekeepingForBolo**

Obtain the channel housekeeping information for a bolometer named "bolo"
using the passed housekeeping and wiring maps.

If all_hk is True, returns a tuple of the (board, mezz, module, channel)
HK data instead of just the channel.

*Definition:*
        ``HousekeepingForBolo(hkmap, wiringmap, bolo, all_hk=False)``




.. _spt3g.dfmux.unittransforms.get_timestream_unit_conversion:

**spt3g.dfmux.unittransforms.get_timestream_unit_conversion**

Return the scalar conversion factor to move timestream data from a
given system of units (Power, Resistance, Current, Counts) to another one.
Requires a wiring map and recent housekeeping data.
Returned quantities are RMS for currents and time-averaged for power.

Note that this does not handle conversions to on-sky quantities (e.g. K_cmb)

*Definition:*
        ``get_timestream_unit_conversion(from_units, to_units, bolo, wiringmap=None, hkmap=None, system=None, tf=None)``




