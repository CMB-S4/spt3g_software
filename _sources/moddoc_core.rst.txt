----
core
----

The core directory includes infrastructural components of the software: file IO, python bindings, basic containers for plain data, the definition of G3Pipeline, etc.


Frame Objects in spt3g.core
===========================
* spt3g.core.G3Bool_

* spt3g.core.G3Double_

* spt3g.core.G3FrameObject_

* spt3g.core.G3Int_

* spt3g.core.G3MapDouble_

* spt3g.core.G3MapFrameObject_

* spt3g.core.G3MapInt_

* spt3g.core.G3MapMapDouble_

* spt3g.core.G3MapString_

* spt3g.core.G3MapVectorBool_

* spt3g.core.G3MapVectorComplexDouble_

* spt3g.core.G3MapVectorDouble_

* spt3g.core.G3MapVectorInt_

* spt3g.core.G3MapVectorString_

* spt3g.core.G3MapVectorTime_

* spt3g.core.G3MapVectorVectorString_

* spt3g.core.G3ModuleConfig_

* spt3g.core.G3PipelineInfo_

* spt3g.core.G3String_

* spt3g.core.G3Time_

* spt3g.core.G3TimesampleMap_

* spt3g.core.G3Timestream_

* spt3g.core.G3TimestreamMap_

* spt3g.core.G3TimestreamQuat_

* spt3g.core.G3VectorBool_

* spt3g.core.G3VectorComplexDouble_

* spt3g.core.G3VectorDouble_

* spt3g.core.G3VectorFrameObject_

* spt3g.core.G3VectorInt_

* spt3g.core.G3VectorQuat_

* spt3g.core.G3VectorString_

* spt3g.core.G3VectorTime_

* spt3g.core.G3VectorUnsignedChar_

* spt3g.core.G3VectorVectorString_


.. _spt3g.core.G3Bool:

spt3g.core.G3Bool
-----------------

Serializable boolean type

*Constructors:*
	``G3Bool( (bool)arg2)``
	
	``G3Bool( (G3Bool)arg2)``




.. _spt3g.core.G3Double:

spt3g.core.G3Double
-------------------

Serializable double

*Constructors:*
	``G3Double( (float)arg2)``
	
	``G3Double( (G3Double)arg2)``




.. _spt3g.core.G3FrameObject:

spt3g.core.G3FrameObject
------------------------

Base class for objects that can be added to a frame. All such must inherit from G3FrameObject in C++. Pickle hooks are overridden to use the fast internal serialization

*Constructors:*
	``G3FrameObject()``



*Methods:*

.. _spt3g.core.G3FrameObject.Description:

**spt3g.core.G3FrameObject.Description**

``Description( (G3FrameObject)arg1) -> str :``
    Long-form human-readable description of the object

.. _spt3g.core.G3FrameObject.Summary:

**spt3g.core.G3FrameObject.Summary**

``Summary( (G3FrameObject)arg1) -> str :``
    Short (one-line) description of the object



.. _spt3g.core.G3Int:

spt3g.core.G3Int
----------------

Serializable integer type

*Constructors:*
	``G3Int( (int)arg2)``
	
	``G3Int( (G3Int)arg2)``




.. _spt3g.core.G3MapDouble:

spt3g.core.G3MapDouble
----------------------

Mapping from strings to floats

*Constructors:*
	``G3MapDouble()``
	
	``G3MapDouble( (G3MapDouble)arg2)``
	
	``G3MapDouble( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapDouble( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapDouble()``



*Methods:*

.. _spt3g.core.G3MapDouble.keys:

**spt3g.core.G3MapDouble.keys**

``keys( (G3MapDouble)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapDouble.has_key:

**spt3g.core.G3MapDouble.has_key**

``has_key( (G3MapDouble)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapDouble.values:

**spt3g.core.G3MapDouble.values**

``values( (G3MapDouble)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapDouble.items:

**spt3g.core.G3MapDouble.items**

``items( (G3MapDouble)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapDouble.clear:

**spt3g.core.G3MapDouble.clear**

``clear( (G3MapDouble)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapDouble.copy:

**spt3g.core.G3MapDouble.copy**

``copy( (G3MapDouble)arg1) -> G3MapDouble :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapDouble.get:

**spt3g.core.G3MapDouble.get**

``get( (G3MapDouble)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapDouble.pop:

**spt3g.core.G3MapDouble.pop**

``pop( (G3MapDouble)arg1, (str)arg2) -> object``

``pop( (G3MapDouble)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapDouble.popitem:

**spt3g.core.G3MapDouble.popitem**

``popitem( (G3MapDouble)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapDouble.update:

**spt3g.core.G3MapDouble.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapDouble.iteritems:

**spt3g.core.G3MapDouble.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapDouble.iterkeys:

**spt3g.core.G3MapDouble.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapDouble.itervalues:

**spt3g.core.G3MapDouble.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapFrameObject:

spt3g.core.G3MapFrameObject
---------------------------

Mapping strings to generic frame objects. Can lead to a variety of paradoxes; please avoid general use of this class.

*Constructors:*
	``G3MapFrameObject()``
	
	``G3MapFrameObject( (G3MapFrameObject)arg2)``
	
	``G3MapFrameObject( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapFrameObject( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapFrameObject()``



*Methods:*

.. _spt3g.core.G3MapFrameObject.keys:

**spt3g.core.G3MapFrameObject.keys**

``keys( (G3MapFrameObject)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapFrameObject.has_key:

**spt3g.core.G3MapFrameObject.has_key**

``has_key( (G3MapFrameObject)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapFrameObject.values:

**spt3g.core.G3MapFrameObject.values**

``values( (G3MapFrameObject)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapFrameObject.items:

**spt3g.core.G3MapFrameObject.items**

``items( (G3MapFrameObject)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapFrameObject.clear:

**spt3g.core.G3MapFrameObject.clear**

``clear( (G3MapFrameObject)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapFrameObject.copy:

**spt3g.core.G3MapFrameObject.copy**

``copy( (G3MapFrameObject)arg1) -> G3MapFrameObject :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapFrameObject.get:

**spt3g.core.G3MapFrameObject.get**

``get( (G3MapFrameObject)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapFrameObject.pop:

**spt3g.core.G3MapFrameObject.pop**

``pop( (G3MapFrameObject)arg1, (str)arg2) -> object``

``pop( (G3MapFrameObject)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapFrameObject.popitem:

**spt3g.core.G3MapFrameObject.popitem**

``popitem( (G3MapFrameObject)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapFrameObject.update:

**spt3g.core.G3MapFrameObject.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapFrameObject.iteritems:

**spt3g.core.G3MapFrameObject.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapFrameObject.iterkeys:

**spt3g.core.G3MapFrameObject.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapFrameObject.itervalues:

**spt3g.core.G3MapFrameObject.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapInt:

spt3g.core.G3MapInt
-------------------

Mapping from strings to ints.

*Constructors:*
	``G3MapInt()``
	
	``G3MapInt( (G3MapInt)arg2)``
	
	``G3MapInt( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapInt( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapInt()``



*Methods:*

.. _spt3g.core.G3MapInt.keys:

**spt3g.core.G3MapInt.keys**

``keys( (G3MapInt)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapInt.has_key:

**spt3g.core.G3MapInt.has_key**

``has_key( (G3MapInt)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapInt.values:

**spt3g.core.G3MapInt.values**

``values( (G3MapInt)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapInt.items:

**spt3g.core.G3MapInt.items**

``items( (G3MapInt)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapInt.clear:

**spt3g.core.G3MapInt.clear**

``clear( (G3MapInt)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapInt.copy:

**spt3g.core.G3MapInt.copy**

``copy( (G3MapInt)arg1) -> G3MapInt :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapInt.get:

**spt3g.core.G3MapInt.get**

``get( (G3MapInt)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapInt.pop:

**spt3g.core.G3MapInt.pop**

``pop( (G3MapInt)arg1, (str)arg2) -> object``

``pop( (G3MapInt)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapInt.popitem:

**spt3g.core.G3MapInt.popitem**

``popitem( (G3MapInt)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapInt.update:

**spt3g.core.G3MapInt.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapInt.iteritems:

**spt3g.core.G3MapInt.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapInt.iterkeys:

**spt3g.core.G3MapInt.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapInt.itervalues:

**spt3g.core.G3MapInt.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapMapDouble:

spt3g.core.G3MapMapDouble
-------------------------

Mapping from strings to maps of strings to floats. For example, m['Det1']['Det2'] = 5.3

*Constructors:*
	``G3MapMapDouble()``
	
	``G3MapMapDouble( (G3MapMapDouble)arg2)``
	
	``G3MapMapDouble( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapMapDouble( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapMapDouble()``



*Methods:*

.. _spt3g.core.G3MapMapDouble.keys:

**spt3g.core.G3MapMapDouble.keys**

``keys( (G3MapMapDouble)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapMapDouble.has_key:

**spt3g.core.G3MapMapDouble.has_key**

``has_key( (G3MapMapDouble)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapMapDouble.values:

**spt3g.core.G3MapMapDouble.values**

``values( (G3MapMapDouble)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapMapDouble.items:

**spt3g.core.G3MapMapDouble.items**

``items( (G3MapMapDouble)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapMapDouble.clear:

**spt3g.core.G3MapMapDouble.clear**

``clear( (G3MapMapDouble)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapMapDouble.copy:

**spt3g.core.G3MapMapDouble.copy**

``copy( (G3MapMapDouble)arg1) -> G3MapMapDouble :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapMapDouble.get:

**spt3g.core.G3MapMapDouble.get**

``get( (G3MapMapDouble)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapMapDouble.pop:

**spt3g.core.G3MapMapDouble.pop**

``pop( (G3MapMapDouble)arg1, (str)arg2) -> object``

``pop( (G3MapMapDouble)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapMapDouble.popitem:

**spt3g.core.G3MapMapDouble.popitem**

``popitem( (G3MapMapDouble)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapMapDouble.update:

**spt3g.core.G3MapMapDouble.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapMapDouble.iteritems:

**spt3g.core.G3MapMapDouble.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapMapDouble.iterkeys:

**spt3g.core.G3MapMapDouble.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapMapDouble.itervalues:

**spt3g.core.G3MapMapDouble.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapString:

spt3g.core.G3MapString
----------------------

Mapping from strings to strings.

*Constructors:*
	``G3MapString()``
	
	``G3MapString( (G3MapString)arg2)``
	
	``G3MapString( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapString( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapString()``



*Methods:*

.. _spt3g.core.G3MapString.keys:

**spt3g.core.G3MapString.keys**

``keys( (G3MapString)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapString.has_key:

**spt3g.core.G3MapString.has_key**

``has_key( (G3MapString)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapString.values:

**spt3g.core.G3MapString.values**

``values( (G3MapString)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapString.items:

**spt3g.core.G3MapString.items**

``items( (G3MapString)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapString.clear:

**spt3g.core.G3MapString.clear**

``clear( (G3MapString)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapString.copy:

**spt3g.core.G3MapString.copy**

``copy( (G3MapString)arg1) -> G3MapString :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapString.get:

**spt3g.core.G3MapString.get**

``get( (G3MapString)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapString.pop:

**spt3g.core.G3MapString.pop**

``pop( (G3MapString)arg1, (str)arg2) -> object``

``pop( (G3MapString)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapString.popitem:

**spt3g.core.G3MapString.popitem**

``popitem( (G3MapString)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapString.update:

**spt3g.core.G3MapString.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapString.iteritems:

**spt3g.core.G3MapString.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapString.iterkeys:

**spt3g.core.G3MapString.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapString.itervalues:

**spt3g.core.G3MapString.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorBool:

spt3g.core.G3MapVectorBool
--------------------------

Mapping from strings to arrays of booleans.

*Constructors:*
	``G3MapVectorBool()``
	
	``G3MapVectorBool( (G3MapVectorBool)arg2)``
	
	``G3MapVectorBool( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorBool( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorBool()``



*Methods:*

.. _spt3g.core.G3MapVectorBool.keys:

**spt3g.core.G3MapVectorBool.keys**

``keys( (G3MapVectorBool)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorBool.has_key:

**spt3g.core.G3MapVectorBool.has_key**

``has_key( (G3MapVectorBool)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorBool.values:

**spt3g.core.G3MapVectorBool.values**

``values( (G3MapVectorBool)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorBool.items:

**spt3g.core.G3MapVectorBool.items**

``items( (G3MapVectorBool)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorBool.clear:

**spt3g.core.G3MapVectorBool.clear**

``clear( (G3MapVectorBool)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorBool.copy:

**spt3g.core.G3MapVectorBool.copy**

``copy( (G3MapVectorBool)arg1) -> G3MapVectorBool :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorBool.get:

**spt3g.core.G3MapVectorBool.get**

``get( (G3MapVectorBool)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorBool.pop:

**spt3g.core.G3MapVectorBool.pop**

``pop( (G3MapVectorBool)arg1, (str)arg2) -> object``

``pop( (G3MapVectorBool)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorBool.popitem:

**spt3g.core.G3MapVectorBool.popitem**

``popitem( (G3MapVectorBool)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorBool.update:

**spt3g.core.G3MapVectorBool.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorBool.iteritems:

**spt3g.core.G3MapVectorBool.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorBool.iterkeys:

**spt3g.core.G3MapVectorBool.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorBool.itervalues:

**spt3g.core.G3MapVectorBool.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorComplexDouble:

spt3g.core.G3MapVectorComplexDouble
-----------------------------------

Mapping from strings to arrays of complex numbers.

*Constructors:*
	``G3MapVectorComplexDouble()``
	
	``G3MapVectorComplexDouble( (G3MapVectorComplexDouble)arg2)``
	
	``G3MapVectorComplexDouble( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorComplexDouble( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorComplexDouble()``



*Methods:*

.. _spt3g.core.G3MapVectorComplexDouble.keys:

**spt3g.core.G3MapVectorComplexDouble.keys**

``keys( (G3MapVectorComplexDouble)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorComplexDouble.has_key:

**spt3g.core.G3MapVectorComplexDouble.has_key**

``has_key( (G3MapVectorComplexDouble)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorComplexDouble.values:

**spt3g.core.G3MapVectorComplexDouble.values**

``values( (G3MapVectorComplexDouble)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorComplexDouble.items:

**spt3g.core.G3MapVectorComplexDouble.items**

``items( (G3MapVectorComplexDouble)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorComplexDouble.clear:

**spt3g.core.G3MapVectorComplexDouble.clear**

``clear( (G3MapVectorComplexDouble)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorComplexDouble.copy:

**spt3g.core.G3MapVectorComplexDouble.copy**

``copy( (G3MapVectorComplexDouble)arg1) -> G3MapVectorComplexDouble :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorComplexDouble.get:

**spt3g.core.G3MapVectorComplexDouble.get**

``get( (G3MapVectorComplexDouble)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorComplexDouble.pop:

**spt3g.core.G3MapVectorComplexDouble.pop**

``pop( (G3MapVectorComplexDouble)arg1, (str)arg2) -> object``

``pop( (G3MapVectorComplexDouble)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorComplexDouble.popitem:

**spt3g.core.G3MapVectorComplexDouble.popitem**

``popitem( (G3MapVectorComplexDouble)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorComplexDouble.update:

**spt3g.core.G3MapVectorComplexDouble.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorComplexDouble.iteritems:

**spt3g.core.G3MapVectorComplexDouble.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorComplexDouble.iterkeys:

**spt3g.core.G3MapVectorComplexDouble.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorComplexDouble.itervalues:

**spt3g.core.G3MapVectorComplexDouble.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorDouble:

spt3g.core.G3MapVectorDouble
----------------------------

Mapping from strings to arrays of floats.

*Constructors:*
	``G3MapVectorDouble()``
	
	``G3MapVectorDouble( (G3MapVectorDouble)arg2)``
	
	``G3MapVectorDouble( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorDouble( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorDouble()``



*Methods:*

.. _spt3g.core.G3MapVectorDouble.keys:

**spt3g.core.G3MapVectorDouble.keys**

``keys( (G3MapVectorDouble)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorDouble.has_key:

**spt3g.core.G3MapVectorDouble.has_key**

``has_key( (G3MapVectorDouble)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorDouble.values:

**spt3g.core.G3MapVectorDouble.values**

``values( (G3MapVectorDouble)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorDouble.items:

**spt3g.core.G3MapVectorDouble.items**

``items( (G3MapVectorDouble)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorDouble.clear:

**spt3g.core.G3MapVectorDouble.clear**

``clear( (G3MapVectorDouble)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorDouble.copy:

**spt3g.core.G3MapVectorDouble.copy**

``copy( (G3MapVectorDouble)arg1) -> G3MapVectorDouble :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorDouble.get:

**spt3g.core.G3MapVectorDouble.get**

``get( (G3MapVectorDouble)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorDouble.pop:

**spt3g.core.G3MapVectorDouble.pop**

``pop( (G3MapVectorDouble)arg1, (str)arg2) -> object``

``pop( (G3MapVectorDouble)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorDouble.popitem:

**spt3g.core.G3MapVectorDouble.popitem**

``popitem( (G3MapVectorDouble)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorDouble.update:

**spt3g.core.G3MapVectorDouble.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorDouble.iteritems:

**spt3g.core.G3MapVectorDouble.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorDouble.iterkeys:

**spt3g.core.G3MapVectorDouble.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorDouble.itervalues:

**spt3g.core.G3MapVectorDouble.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorInt:

spt3g.core.G3MapVectorInt
-------------------------

Mapping from strings to arrays of integers.

*Constructors:*
	``G3MapVectorInt()``
	
	``G3MapVectorInt( (G3MapVectorInt)arg2)``
	
	``G3MapVectorInt( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorInt( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorInt()``



*Methods:*

.. _spt3g.core.G3MapVectorInt.keys:

**spt3g.core.G3MapVectorInt.keys**

``keys( (G3MapVectorInt)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorInt.has_key:

**spt3g.core.G3MapVectorInt.has_key**

``has_key( (G3MapVectorInt)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorInt.values:

**spt3g.core.G3MapVectorInt.values**

``values( (G3MapVectorInt)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorInt.items:

**spt3g.core.G3MapVectorInt.items**

``items( (G3MapVectorInt)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorInt.clear:

**spt3g.core.G3MapVectorInt.clear**

``clear( (G3MapVectorInt)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorInt.copy:

**spt3g.core.G3MapVectorInt.copy**

``copy( (G3MapVectorInt)arg1) -> G3MapVectorInt :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorInt.get:

**spt3g.core.G3MapVectorInt.get**

``get( (G3MapVectorInt)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorInt.pop:

**spt3g.core.G3MapVectorInt.pop**

``pop( (G3MapVectorInt)arg1, (str)arg2) -> object``

``pop( (G3MapVectorInt)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorInt.popitem:

**spt3g.core.G3MapVectorInt.popitem**

``popitem( (G3MapVectorInt)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorInt.update:

**spt3g.core.G3MapVectorInt.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorInt.iteritems:

**spt3g.core.G3MapVectorInt.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorInt.iterkeys:

**spt3g.core.G3MapVectorInt.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorInt.itervalues:

**spt3g.core.G3MapVectorInt.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorString:

spt3g.core.G3MapVectorString
----------------------------

Mapping from strings to lists of strings.

*Constructors:*
	``G3MapVectorString()``
	
	``G3MapVectorString( (G3MapVectorString)arg2)``
	
	``G3MapVectorString( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorString( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorString()``



*Methods:*

.. _spt3g.core.G3MapVectorString.keys:

**spt3g.core.G3MapVectorString.keys**

``keys( (G3MapVectorString)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorString.has_key:

**spt3g.core.G3MapVectorString.has_key**

``has_key( (G3MapVectorString)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorString.values:

**spt3g.core.G3MapVectorString.values**

``values( (G3MapVectorString)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorString.items:

**spt3g.core.G3MapVectorString.items**

``items( (G3MapVectorString)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorString.clear:

**spt3g.core.G3MapVectorString.clear**

``clear( (G3MapVectorString)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorString.copy:

**spt3g.core.G3MapVectorString.copy**

``copy( (G3MapVectorString)arg1) -> G3MapVectorString :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorString.get:

**spt3g.core.G3MapVectorString.get**

``get( (G3MapVectorString)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorString.pop:

**spt3g.core.G3MapVectorString.pop**

``pop( (G3MapVectorString)arg1, (str)arg2) -> object``

``pop( (G3MapVectorString)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorString.popitem:

**spt3g.core.G3MapVectorString.popitem**

``popitem( (G3MapVectorString)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorString.update:

**spt3g.core.G3MapVectorString.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorString.iteritems:

**spt3g.core.G3MapVectorString.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorString.iterkeys:

**spt3g.core.G3MapVectorString.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorString.itervalues:

**spt3g.core.G3MapVectorString.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorTime:

spt3g.core.G3MapVectorTime
--------------------------

Mapping from strings to lists of G3 time objects.

*Constructors:*
	``G3MapVectorTime()``
	
	``G3MapVectorTime( (G3MapVectorTime)arg2)``
	
	``G3MapVectorTime( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorTime( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorTime()``



*Methods:*

.. _spt3g.core.G3MapVectorTime.keys:

**spt3g.core.G3MapVectorTime.keys**

``keys( (G3MapVectorTime)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorTime.has_key:

**spt3g.core.G3MapVectorTime.has_key**

``has_key( (G3MapVectorTime)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorTime.values:

**spt3g.core.G3MapVectorTime.values**

``values( (G3MapVectorTime)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorTime.items:

**spt3g.core.G3MapVectorTime.items**

``items( (G3MapVectorTime)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorTime.clear:

**spt3g.core.G3MapVectorTime.clear**

``clear( (G3MapVectorTime)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorTime.copy:

**spt3g.core.G3MapVectorTime.copy**

``copy( (G3MapVectorTime)arg1) -> G3MapVectorTime :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorTime.get:

**spt3g.core.G3MapVectorTime.get**

``get( (G3MapVectorTime)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorTime.pop:

**spt3g.core.G3MapVectorTime.pop**

``pop( (G3MapVectorTime)arg1, (str)arg2) -> object``

``pop( (G3MapVectorTime)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorTime.popitem:

**spt3g.core.G3MapVectorTime.popitem**

``popitem( (G3MapVectorTime)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorTime.update:

**spt3g.core.G3MapVectorTime.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorTime.iteritems:

**spt3g.core.G3MapVectorTime.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorTime.iterkeys:

**spt3g.core.G3MapVectorTime.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorTime.itervalues:

**spt3g.core.G3MapVectorTime.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3MapVectorVectorString:

spt3g.core.G3MapVectorVectorString
----------------------------------

Mapping from strings to lists of lists of strings.

*Constructors:*
	``G3MapVectorVectorString()``
	
	``G3MapVectorVectorString( (G3MapVectorVectorString)arg2)``
	
	``G3MapVectorVectorString( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3MapVectorVectorString( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3MapVectorVectorString()``



*Methods:*

.. _spt3g.core.G3MapVectorVectorString.keys:

**spt3g.core.G3MapVectorVectorString.keys**

``keys( (G3MapVectorVectorString)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3MapVectorVectorString.has_key:

**spt3g.core.G3MapVectorVectorString.has_key**

``has_key( (G3MapVectorVectorString)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3MapVectorVectorString.values:

**spt3g.core.G3MapVectorVectorString.values**

``values( (G3MapVectorVectorString)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3MapVectorVectorString.items:

**spt3g.core.G3MapVectorVectorString.items**

``items( (G3MapVectorVectorString)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3MapVectorVectorString.clear:

**spt3g.core.G3MapVectorVectorString.clear**

``clear( (G3MapVectorVectorString)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3MapVectorVectorString.copy:

**spt3g.core.G3MapVectorVectorString.copy**

``copy( (G3MapVectorVectorString)arg1) -> G3MapVectorVectorString :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3MapVectorVectorString.get:

**spt3g.core.G3MapVectorVectorString.get**

``get( (G3MapVectorVectorString)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3MapVectorVectorString.pop:

**spt3g.core.G3MapVectorVectorString.pop**

``pop( (G3MapVectorVectorString)arg1, (str)arg2) -> object``

``pop( (G3MapVectorVectorString)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3MapVectorVectorString.popitem:

**spt3g.core.G3MapVectorVectorString.popitem**

``popitem( (G3MapVectorVectorString)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3MapVectorVectorString.update:

**spt3g.core.G3MapVectorVectorString.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3MapVectorVectorString.iteritems:

**spt3g.core.G3MapVectorVectorString.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3MapVectorVectorString.iterkeys:

**spt3g.core.G3MapVectorVectorString.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3MapVectorVectorString.itervalues:

**spt3g.core.G3MapVectorVectorString.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D



.. _spt3g.core.G3ModuleConfig:

spt3g.core.G3ModuleConfig
-------------------------

Stored configuration of a pipeline module or segment

*Constructors:*
	``G3ModuleConfig()``
	
	``G3ModuleConfig( (G3ModuleConfig)arg2)``



*Members:*

* **modname**: No Doc (Shame!)

* **instancename**: No Doc (Shame!)

* **config**: No Doc (Shame!)



.. _spt3g.core.G3PipelineInfo:

spt3g.core.G3PipelineInfo
-------------------------

Stored configuration of a pipeline, including software version information

*Constructors:*
	``G3PipelineInfo()``
	
	``G3PipelineInfo( (G3PipelineInfo)arg2)``



*Members:*

* **vcs_url**: No Doc (Shame!)

* **vcs_branch**: No Doc (Shame!)

* **vcs_revision**: No Doc (Shame!)

* **vcs_localdiffs**: No Doc (Shame!)

* **vcs_versionname**: No Doc (Shame!)

* **vcs_fullversion**: No Doc (Shame!)

* **vcs_githash**: No Doc (Shame!)

* **hostname**: No Doc (Shame!)

* **user**: No Doc (Shame!)

* **modules**: No Doc (Shame!)



.. _spt3g.core.G3String:

spt3g.core.G3String
-------------------

Serializable string

*Constructors:*
	``G3String( (str)arg2)``
	
	``G3String( (G3String)arg2)``




.. _spt3g.core.G3Time:

spt3g.core.G3Time
-----------------

UTC Time

*Constructors:*
	``G3Time()``
	
	``G3Time( (G3Time)arg2)``
	
	``G3Time( (int)y, (int)d, (int)h, (int)m, (int)s, (int)ss)`` :
	    Create a timestamp object from IRIG B code
	
	``G3Time( (str)arg2)`` :
	    Create a time object from a string representation. Supported formats are: YYYYMMDD_HHMMSS, YYMMDD_HHMMSS, YYMMDD HH:MM:SS, DD-Mon-YYYY:HH:MM:SS, YYYY-MM-DDTHH:MM:SS[+TZ] (ISO 8601). All can have a fraction of second field after a dot.
	
	``G3Time( (object)timestamp)`` :
	    Create a G3Time from a numeric timestamp



*Members:*

* **time**: Time relative to the UNIX epoch

* **mjd**: Time in MJD


*Methods:*

.. _spt3g.core.G3Time.GetFileFormatString:

**spt3g.core.G3Time.GetFileFormatString**

``GetFileFormatString( (G3Time)arg1) -> str :``
    Get a string corresponding to how SPTpol and GCP name files for this time

.. _spt3g.core.G3Time.isoformat:

**spt3g.core.G3Time.isoformat**

``isoformat( (G3Time)arg1) -> str :``
    Return the ISO 8601 formatted timestamp string



.. _spt3g.core.G3TimesampleMap:

spt3g.core.G3TimesampleMap
--------------------------

Mapping from string to vectors of data, with an associated vector of timestamps.  This object is for storing multiple co-sampled vectors with a single set of (irregular) timestamps.

*Constructors:*
	``G3TimesampleMap()``
	
	``G3TimesampleMap( (G3TimesampleMap)arg2)``
	
	``G3TimesampleMap( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3TimesampleMap( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3TimesampleMap()``



*Members:*

* **times**: Times vector.  Setting this stores a copy, but getting returns a reference.


*Methods:*

.. _spt3g.core.G3TimesampleMap.keys:

**spt3g.core.G3TimesampleMap.keys**

``keys( (G3TimesampleMap)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3TimesampleMap.has_key:

**spt3g.core.G3TimesampleMap.has_key**

``has_key( (G3TimesampleMap)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3TimesampleMap.values:

**spt3g.core.G3TimesampleMap.values**

``values( (G3TimesampleMap)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3TimesampleMap.items:

**spt3g.core.G3TimesampleMap.items**

``items( (G3TimesampleMap)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3TimesampleMap.clear:

**spt3g.core.G3TimesampleMap.clear**

``clear( (G3TimesampleMap)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3TimesampleMap.copy:

**spt3g.core.G3TimesampleMap.copy**

``copy( (G3TimesampleMap)arg1) -> G3TimesampleMap :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3TimesampleMap.get:

**spt3g.core.G3TimesampleMap.get**

``get( (G3TimesampleMap)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3TimesampleMap.pop:

**spt3g.core.G3TimesampleMap.pop**

``pop( (G3TimesampleMap)arg1, (str)arg2) -> object``

``pop( (G3TimesampleMap)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3TimesampleMap.popitem:

**spt3g.core.G3TimesampleMap.popitem**

``popitem( (G3TimesampleMap)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3TimesampleMap.update:

**spt3g.core.G3TimesampleMap.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3TimesampleMap.iteritems:

**spt3g.core.G3TimesampleMap.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3TimesampleMap.iterkeys:

**spt3g.core.G3TimesampleMap.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3TimesampleMap.itervalues:

**spt3g.core.G3TimesampleMap.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D

.. _spt3g.core.G3TimesampleMap.check:

**spt3g.core.G3TimesampleMap.check**

``check( (G3TimesampleMap)arg1) -> bool :``
    Check for internal consistency.  Raises ValueError if there are problems.

.. _spt3g.core.G3TimesampleMap.concatenate:

**spt3g.core.G3TimesampleMap.concatenate**

``concatenate( (G3TimesampleMap)arg1, (G3TimesampleMap)arg2) -> G3TimesampleMap :``
    Concatenate two compatible G3TimesampleMap.

.. _spt3g.core.G3TimesampleMap.sort:

**spt3g.core.G3TimesampleMap.sort**

``sort( (G3TimesampleMap)arg1) -> None :``
    Sort all element vectors by time, in-place.



.. _spt3g.core.G3Timestream:

spt3g.core.G3Timestream
-----------------------

Detector timestream. Includes a units field and start and stop times. Can otherwise be treated as a numpy array with a float64 dtype. Conversions to and from such arrays (e.g. with numpy.asarray) are fast. Note that a numpy array constructed from a timestream will share a memory buffer: changes to the array affect the timestream and vice versa. Most binary timestream arithmetic operations (+, -) check that the units and start/stop times are congruent.

*Constructors:*
	``G3Timestream()``
	
	``G3Timestream( (G3Timestream)arg2)``
	
	``G3Timestream( (object)data [, (G3TimestreamUnits)units=spt3g.core.G3TimestreamUnits.None])`` :
	    Create a timestream from a numpy array or other numeric python iterable



*Members:*

* **units**: Units of the data in the timestream, stored as one of the members of core.G3TimestreamUnits.

* **start**: Time of the first sample in the time stream

* **stop**: Time of the final sample in the timestream

* **sample_rate**: Computed sample rate of the timestream.

* **n_samples**: Number of samples in the timestream. Equivalent to len(ts)

* **compression_level**: Level of FLAC compression used for this timestream. This can only be non-zero if the timestream is in units of counts.

* **shape**: No Doc (Shame!)

* **ndim**: No Doc (Shame!)

* **dtype**: No Doc (Shame!)

* **elapsed**: Compute elapsed time array for samples.

* **times**: Compute time vector for samples.


*Methods:*

.. _spt3g.core.G3Timestream.SetFLACCompression:

**spt3g.core.G3Timestream.SetFLACCompression**

``SetFLACCompression( (G3Timestream)arg1, (int)arg2) -> None :``
    Pass True to turn on FLAC compression when serialized. FLAC compression only works if the timestream is in units of counts.



.. _spt3g.core.G3TimestreamMap:

spt3g.core.G3TimestreamMap
--------------------------

Collection of timestreams indexed by logical detector ID

*Constructors:*
	``G3TimestreamMap()``
	
	``G3TimestreamMap( (G3TimestreamMap)arg2)``
	
	``G3TimestreamMap( (StringVector)keys, (object)data [, (G3Time)start=<spt3g.core.G3Time object at 0x7f6c09969eb0> [, (G3Time)stop=<spt3g.core.G3Time object at 0x7f6c09969f20> [, (G3TimestreamUnits)units=spt3g.core.G3TimestreamUnits.None [, (int)compression_level=0 [, (bool)copy_data=True]]]]])`` :
	    Create a timestream map from a numpy array or other numeric python iterable. Each row of the 2D input array will correspond to a single timestream, with the key set to the correspondingly-indexed entry of <keys>. If <copy_data> is True (default), the data will be copied into the output data structure. If False, the timestream map will provide a view into the given numpy array.
	
	``G3TimestreamMap( (list)arg2)`` :
	    Initialize with keys and values from a Python dictionary: {'key':'value'}
	
	
	``G3TimestreamMap( (dict)arg2)`` :
	    Initialize with keys and values as tuples in a Python list: [('key','value')]
	
	
	``G3TimestreamMap()``



*Members:*

* **start**: Time of the first sample in the time stream

* **stop**: Time of the final sample in the time stream

* **sample_rate**: Computed sample rate of the timestream.

* **n_samples**: Number of samples in the timestream. Equivalent to the length of one of the timestreams.

* **units**: Units of the data in the timestream, stored as one of the members of core.G3TimestreamUnits.

* **dtype**: No Doc (Shame!)

* **elapsed**: Compute elapsed time array for samples.

* **times**: Compute time vector for samples.

* **names**: Get timestream map channel names.

* **data**: Return a numpy array view into the underlying 2D array of the timestream map


*Methods:*

.. _spt3g.core.G3TimestreamMap.keys:

**spt3g.core.G3TimestreamMap.keys**

``keys( (G3TimestreamMap)arg1) -> list :``
    D.keys() -> list of D's keys

.. _spt3g.core.G3TimestreamMap.has_key:

**spt3g.core.G3TimestreamMap.has_key**

``has_key( (G3TimestreamMap)arg1, (str)arg2) -> bool :``
    D.has_key(k) -> True if D has a key k, else False

.. _spt3g.core.G3TimestreamMap.values:

**spt3g.core.G3TimestreamMap.values**

``values( (G3TimestreamMap)arg1) -> list :``
    D.values() -> list of D's values

.. _spt3g.core.G3TimestreamMap.items:

**spt3g.core.G3TimestreamMap.items**

``items( (G3TimestreamMap)arg1) -> list :``
    D.items() -> list of D's (key, value) pairs, as 2-tuples

.. _spt3g.core.G3TimestreamMap.clear:

**spt3g.core.G3TimestreamMap.clear**

``clear( (G3TimestreamMap)arg1) -> None :``
    D.clear() -> None.  Remove all items from D.

.. _spt3g.core.G3TimestreamMap.copy:

**spt3g.core.G3TimestreamMap.copy**

``copy( (G3TimestreamMap)arg1) -> G3TimestreamMap :``
    D.copy() -> a shallow copy of D

.. _spt3g.core.G3TimestreamMap.get:

**spt3g.core.G3TimestreamMap.get**

``get( (G3TimestreamMap)arg1, (str)arg2 [, (object)default_val]) -> object :``
    D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

.. _spt3g.core.G3TimestreamMap.pop:

**spt3g.core.G3TimestreamMap.pop**

``pop( (G3TimestreamMap)arg1, (str)arg2) -> object``

``pop( (G3TimestreamMap)arg1, (str)arg2, (object)arg3) -> object :``
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value
    If key is not found, d is returned if given, otherwise KeyError is raised

.. _spt3g.core.G3TimestreamMap.popitem:

**spt3g.core.G3TimestreamMap.popitem**

``popitem( (G3TimestreamMap)arg1) -> object :``
    D.popitem() -> (k, v), remove and return some (key, value) pair as a
    2-tuple; but raise KeyError if D is empty

.. _spt3g.core.G3TimestreamMap.update:

**spt3g.core.G3TimestreamMap.update**

``update( (object)arg1, (object)arg2) -> None :``
    D.update(E) -> None.  Update D from E: for k in E: D[k] = E[k]

.. _spt3g.core.G3TimestreamMap.iteritems:

**spt3g.core.G3TimestreamMap.iteritems**

``iteritems( (object)arg1) -> object :``
    D.iteritems() -> an iterator over the (key, value) items of D

.. _spt3g.core.G3TimestreamMap.iterkeys:

**spt3g.core.G3TimestreamMap.iterkeys**

``iterkeys( (object)arg1) -> object :``
    D.iterkeys() -> an iterator over the keys of D

.. _spt3g.core.G3TimestreamMap.itervalues:

**spt3g.core.G3TimestreamMap.itervalues**

``itervalues( (object)arg1) -> object :``
    D.itervalues() -> an iterator over the values of D

.. _spt3g.core.G3TimestreamMap.CheckAlignment:

**spt3g.core.G3TimestreamMap.CheckAlignment**

``CheckAlignment( (G3TimestreamMap)arg1) -> bool``

.. _spt3g.core.G3TimestreamMap.Compactify:

**spt3g.core.G3TimestreamMap.Compactify**

``Compactify( (G3TimestreamMap)arg1) -> None :``
    If member timestreams are stored non-contiguously, repack all data into a contiguous block. Requires timestreams be aligned and the same data type. Done implicitly by numpy.asarray().



.. _spt3g.core.G3TimestreamQuat:

spt3g.core.G3TimestreamQuat
---------------------------

Timestream of quaternions. Identical to a G3VectorQuat except for the addition of start and stop times.

*Constructors:*
	``G3TimestreamQuat()``
	
	``G3TimestreamQuat( (object)arg2)``
	
	``G3TimestreamQuat( (G3TimestreamQuat)arg2)``



*Members:*

* **start**: Time of the first sample in the time stream

* **stop**: Time of the final sample in the timestream

* **sample_rate**: Computed sample rate of the timestream.

* **n_samples**: Number of samples in the timestream. Equivalent to len(ts)



.. _spt3g.core.G3VectorBool:

spt3g.core.G3VectorBool
-----------------------

List of booleans.

*Constructors:*
	``G3VectorBool()``
	
	``G3VectorBool( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorBool.append:

**spt3g.core.G3VectorBool.append**

``append( (G3VectorBool)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorBool.extend:

**spt3g.core.G3VectorBool.extend**

``extend( (G3VectorBool)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorComplexDouble:

spt3g.core.G3VectorComplexDouble
--------------------------------

Array of complex floats. Treat as a serializable version of numpy.array(dtype=complex128). Can be efficiently cast to and from numpy arrays.

*Constructors:*
	``G3VectorComplexDouble()``
	
	``G3VectorComplexDouble( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorComplexDouble.append:

**spt3g.core.G3VectorComplexDouble.append**

``append( (G3VectorComplexDouble)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorComplexDouble.extend:

**spt3g.core.G3VectorComplexDouble.extend**

``extend( (G3VectorComplexDouble)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorDouble:

spt3g.core.G3VectorDouble
-------------------------

Array of floats. Treat as a serializable version of numpy.array(dtype=float64). Can be efficiently cast to and from numpy arrays.

*Constructors:*
	``G3VectorDouble()``
	
	``G3VectorDouble( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorDouble.append:

**spt3g.core.G3VectorDouble.append**

``append( (G3VectorDouble)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorDouble.extend:

**spt3g.core.G3VectorDouble.extend**

``extend( (G3VectorDouble)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorFrameObject:

spt3g.core.G3VectorFrameObject
------------------------------

List of generic frame objects. Can lead to paradoxes; avoid use of this class unless you are sure you need it.

*Constructors:*
	``G3VectorFrameObject()``
	
	``G3VectorFrameObject( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorFrameObject.append:

**spt3g.core.G3VectorFrameObject.append**

``append( (G3VectorFrameObject)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorFrameObject.extend:

**spt3g.core.G3VectorFrameObject.extend**

``extend( (G3VectorFrameObject)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorInt:

spt3g.core.G3VectorInt
----------------------

Array of integers. Treat as a serializable version of numpy.array(dtype=int64). Can be efficiently cast to and from numpy arrays.

*Constructors:*
	``G3VectorInt()``
	
	``G3VectorInt( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorInt.append:

**spt3g.core.G3VectorInt.append**

``append( (G3VectorInt)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorInt.extend:

**spt3g.core.G3VectorInt.extend**

``extend( (G3VectorInt)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorQuat:

spt3g.core.G3VectorQuat
-----------------------

List of quaternions. Convertible to a 4xN numpy array. Arithmetic operations on this object are fast and provide results given proper quaternion math rather than element-by-element numpy-ish results.

*Constructors:*
	``G3VectorQuat()``
	
	``G3VectorQuat( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorQuat.append:

**spt3g.core.G3VectorQuat.append**

``append( (G3VectorQuat)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorQuat.extend:

**spt3g.core.G3VectorQuat.extend**

``extend( (G3VectorQuat)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorString:

spt3g.core.G3VectorString
-------------------------

List of strings.

*Constructors:*
	``G3VectorString()``
	
	``G3VectorString( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorString.append:

**spt3g.core.G3VectorString.append**

``append( (G3VectorString)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorString.extend:

**spt3g.core.G3VectorString.extend**

``extend( (G3VectorString)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorTime:

spt3g.core.G3VectorTime
-----------------------

List of times.

*Constructors:*
	``G3VectorTime()``
	
	``G3VectorTime( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorTime.append:

**spt3g.core.G3VectorTime.append**

``append( (G3VectorTime)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorTime.extend:

**spt3g.core.G3VectorTime.extend**

``extend( (G3VectorTime)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorUnsignedChar:

spt3g.core.G3VectorUnsignedChar
-------------------------------

List of 8-bit integers

*Constructors:*
	``G3VectorUnsignedChar()``
	
	``G3VectorUnsignedChar( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorUnsignedChar.append:

**spt3g.core.G3VectorUnsignedChar.append**

``append( (G3VectorUnsignedChar)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorUnsignedChar.extend:

**spt3g.core.G3VectorUnsignedChar.extend**

``extend( (G3VectorUnsignedChar)arg1, (object)arg2) -> None``



.. _spt3g.core.G3VectorVectorString:

spt3g.core.G3VectorVectorString
-------------------------------

List of lists of strings.

*Constructors:*
	``G3VectorVectorString()``
	
	``G3VectorVectorString( (object)arg2)``



*Methods:*

.. _spt3g.core.G3VectorVectorString.append:

**spt3g.core.G3VectorVectorString.append**

``append( (G3VectorVectorString)arg1, (object)arg2) -> None``

.. _spt3g.core.G3VectorVectorString.extend:

**spt3g.core.G3VectorVectorString.extend**

``extend( (G3VectorVectorString)arg1, (object)arg2) -> None``


Modules in spt3g.core
=====================
* spt3g.core.G3EventBuilder_

* spt3g.core.G3InfiniteSource_

* spt3g.core.G3Module_

* spt3g.core.G3MultiFileWriter_

* spt3g.core.G3NetworkSender_

* spt3g.core.G3Reader_

* spt3g.core.G3Writer_

* spt3g.core.util.AbortAfterNFrames_

* spt3g.core.util.DeduplicateMetadata_

* spt3g.core.util.Delete_

* spt3g.core.util.DropOrphanMetadata_

* spt3g.core.util.Dump_

* spt3g.core.util.G3NetworkReceiver_

* spt3g.core.util.G3ThrottledNetworkSender_

* spt3g.core.util.InjectDebug_

* spt3g.core.util.InjectFrame_

* spt3g.core.util.Rename_


.. _spt3g.core.G3EventBuilder:

**spt3g.core.G3EventBuilder**

Base class for functors that can be added to a G3Pipeline.



.. _spt3g.core.G3InfiniteSource:

**spt3g.core.G3InfiniteSource**

Emits infinite frames, up to an optional maximum number n



.. _spt3g.core.G3Module:

**spt3g.core.G3Module**

Base class for functors that can be added to a G3Pipeline.



.. _spt3g.core.G3MultiFileWriter:

**spt3g.core.G3MultiFileWriter**

Writes frames to disk into a sequence of files. Once a file exceeds the number of bytes specified in size_limit, it will start a new file. Files are named based on filename. If passed a string for filename with a printf-style specifier, that specifier will be replaced by a zero-indexed sequence number. For example, outfile-%03u.g3.gz would produce a sequence of files named outfile-000.g3.gz, outfile-001.g3.gz, etc. Alternatively, you can pass a callable that is passed the first frame in the new file and the sequence number and returns a path to the new file. Any frames besides Timepoint and Scan frames have the most recent frame of each type prepended to all new files.

More complex behavior can be obtained with the optional divide_on argument. This can be an iterable of frame types (e.g. [core.G3FrameType.Observation]) or a callable. In the iterable case, the presence of any frame with a type in the list will cause the creation of a new file even if the file size threshold has not yet been met. This is useful to create files based on, for example, observation boundaries. For more flexibility, you can also pass a python callable as divide_on. This callable will be passed each frame in turn. If it returns True (or something with positive truth-value), a new file will be started at that frame.



.. _spt3g.core.G3NetworkSender:

**spt3g.core.G3NetworkSender**

Writes frames to a network socket. If hostname is set to '*', will listen on the given port, on all interfaces, instead of connecting to the given port on a remote host. In listen mode, metadata frames (Calibration, Wiring, etc. -- everything but Scan and Timepoint) will be accumulated and the most recent of each will be sent to new clients on connect. Scan and Timepoint frames will be broadcast live to all connected clients. If max_queue_size is set to a non-zero value, Scan and Timepoint frames may be dropped if more than max_queue_size frames are queued for transmission. If n_serializers is set to a non-zero value, the task of serializing frames to be sent will be distributed across that many background threads, which is useful when high throughput of large frames is required, but is otherwise typically not necessary.



.. _spt3g.core.G3Reader:

**spt3g.core.G3Reader**

Read frames from disk. Takes either the path to a file to read or an iterable of files to be read in sequence. If n_frames_to_read is greater than zero, will stop after n_frames_to_read frames rather than at the end of the file[s]. The timeout parameter can used to enable socket timeout for tcp streams, resulting in EOF behavior on expiry; unfortunately this cannot be used for polling, you have to close the connection. Use the `tell` and `seek` methods to record the position of and seek to the beginning of a particular frame in the file.  Set track_filename to True to record the filename for each frame in the ._filename attribute (fragile).



.. _spt3g.core.G3Writer:

**spt3g.core.G3Writer**

Writes frames to disk. Frames will be written to the file specified by filename. If filename ends in .gz, output will be compressed using gzip. To write only some types of frames, pass a list of the desired frame types to the second optional argument (streams). If no streams argument is given, writes all types of frames. If append is set to True, will append frames to its output file rather than overwriting it.



.. _spt3g.core.util.AbortAfterNFrames:

**spt3g.core.util.AbortAfterNFrames**

Stops processing after n_frames frames go by

*Constructor:*
	``AbortAfterNFrames(self, type, n_frames)``




.. _spt3g.core.util.DeduplicateMetadata:

**spt3g.core.util.DeduplicateMetadata**

Drop metadata frames (e.g. Calibration, Wiring) for which the previous
metadata frame of the same type is byte-for-byte identical. This can be
handy when, for example, reading in many files from the G3MultiFileWriter,
which copies metadata frames to the beginning of each file. Considers
all frames not in <dataframetypes> to be metadata (by default, everything
except Timepoint and Scan frames).

*Constructor:*
	``DeduplicateMetadata(self, dataframetype=[spt3g.core.G3FrameType.Timepoint, spt3g.core.G3FrameType.Scan])``




.. _spt3g.core.util.Delete:

**spt3g.core.util.Delete**

Deletes specified keys from frame. If optional type specified, only acts on frames of the given type.


*Definition:*
        ``Delete(frame, keys=[], type=None)``




.. _spt3g.core.util.DropOrphanMetadata:

**spt3g.core.util.DropOrphanMetadata**

Remove metadata frames (e.g. Calibration, Wiring) without
intervening data frames (e.g. Timepoint, Scan, specified by the
<dataframetype> argument to the constructor). The metadata frames that
do show up will be the most recent of each type and appear in their
original order.

*Constructor:*
	``DropOrphanMetadata(self, dataframetype=[spt3g.core.G3FrameType.Timepoint, spt3g.core.G3FrameType.Scan])``




.. _spt3g.core.util.Dump:

**spt3g.core.util.Dump**

Prints frames to console. If optional type specified, only acts on frames of the given type.


*Definition:*
        ``Dump(frame, type=None, added_message=None)``




.. _spt3g.core.util.G3NetworkReceiver:

**spt3g.core.util.G3NetworkReceiver**


Emulation of old G3NetworkReceiver class. Equivalent to pointing
G3Reader at a TCP URL.



*Equivalent to:*

.. code-block:: python

    pipe.Add(spt3g.core.G3Reader, filename='tcp://localhost:5978')



*Definition:*
        ``G3NetworkReceiver(pipe, hostname='localhost', port=5978)``



.. _spt3g.core.util.G3ThrottledNetworkSender:

**spt3g.core.util.G3ThrottledNetworkSender**

Send every Nth frame of certain types using a wrapped G3NetworkSender.
All instances of frames not in the dictionary frame_decimation will be sent
at their full rate.

*Constructor:*
	``G3ThrottledNetworkSender(self, hostname='*', port=5978, frame_decimation={spt3g.core.G3FrameType.Timepoint: 10}, max_queue_size=0)``




.. _spt3g.core.util.InjectDebug:

**spt3g.core.util.InjectDebug**

starts a pdb session when a frame of type shows up.

The frame data is stored in the variable names "frame".

If debug_start_func is not None, only starts a debug session when 
        debug_start_func(frame) == True



*Definition:*
        ``InjectDebug(frame, type=None, debug_start_func=None)``




.. _spt3g.core.util.InjectFrame:

**spt3g.core.util.InjectFrame**

Inject an arbitrary frame into a pipeline.

*Arguments:*
	frame : G3Frame
	    The frame to inject

*Constructor:*
	``InjectFrame(self, frame)``




.. _spt3g.core.util.Rename:

**spt3g.core.util.Rename**

Renames specified keys in frame. If optional type specified, only acts on frames of the given type. Argument is a dictionary mapping old names to new ones.


*Definition:*
        ``Rename(frame, keys={}, type=None)``



Functions in spt3g.core
=======================
* spt3g.core.timestreamextensions.concatenate_timestreams_


.. _spt3g.core.timestreamextensions.concatenate_timestreams:

**spt3g.core.timestreamextensions.concatenate_timestreams**

Concatenate G3Timestream or G3TimestreamMap objects together.

*Arguments:*
	ts_lst : list
	    list of G3Timestream or G3TimestreamMap objects.  Must all be
	    the same type.
	ts_rounding_error : float
	    allowed error in timestream separation such that timestreams are
	    contiguous, as a fraction of the sample rate. This should be
	    0 by default, but is 0.5 to allow for downsampler shifting,
	    and then bumpted again to 0.6 to allow for floating-point
	    errors in what 0.5 is.
	ts_interp_threshold : float
	    allowed timestream separation below which gaps between timestreams are
	    interpolated to be made continuous
	
*Returns:*
	ts : G3Timestream or G3TimestreamMap object
	    The concatenation of the input list of objects

*Definition:*
        ``concatenate_timestreams(ts_lst, ts_rounding_error=0.6, ts_interp_threshold=0)``




