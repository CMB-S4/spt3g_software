<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Modules &#8212; SPT3G Software  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css?v=279e0f84" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Frames" href="frames.html" />
    <link rel="prev" title="Quick Start" href="quickstart.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="frames.html" title="Frames"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="Quick Start"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPT3G Software  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Modules</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="modules">
<h1><a class="toc-backref" href="#id1" role="doc-backlink">Modules</a><a class="headerlink" href="#modules" title="Link to this heading">¶</a></h1>
<p>A module is a processing step for data. Modules operate on frames, and pass frames from their input to their output queues, applying some processing in between. A typical module will operate on one frame at a time, reading data (e.g. bolometer timestreams) from a single input frame, adding new data (e.g. a filtered version of the bolometer timestreams), and then pushing the frame to its output queue for the next module in the chain.</p>
<p>More complex manipulations are possible: the module can create new frames, throw frames away, operate on more than one frame at a time, or some combination of all three. Examples of how to do these things, as well as rationales, appear below.</p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#modules" id="id1">Modules</a></p>
<ul>
<li><p><a class="reference internal" href="#writing-a-module-in-python" id="id2">Writing a module in Python</a></p>
<ul>
<li><p><a class="reference internal" href="#python-modules-as-functions" id="id3">Python Modules as Functions</a></p></li>
<li><p><a class="reference internal" href="#return-values-from-python-modules" id="id4">Return values from Python modules</a></p></li>
<li><p><a class="reference internal" href="#im-mutability-of-frame-objects" id="id5">(Im)mutability of frame objects</a></p></li>
<li><p><a class="reference internal" href="#the-first-module" id="id6">The first module</a></p></li>
<li><p><a class="reference internal" href="#callable-objects-as-functions" id="id7">Callable Objects as Functions</a></p></li>
<li><p><a class="reference internal" href="#autodocumentation-of-modules" id="id8">Autodocumentation of modules</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#writing-a-module-in-c" id="id9">Writing a module in C++</a></p></li>
<li><p><a class="reference internal" href="#pipeline-segments" id="id10">Pipeline Segments</a></p></li>
<li><p><a class="reference internal" href="#advanced-techniques-buffering-data" id="id11">Advanced Techniques: Buffering Data</a></p></li>
<li><p><a class="reference internal" href="#caching-previous-data" id="id12">Caching Previous Data</a></p></li>
<li><p><a class="reference internal" href="#pipelines" id="id13">Pipelines</a></p>
<ul>
<li><p><a class="reference internal" href="#pipeline-add" id="id14">Pipeline.Add</a></p></li>
<li><p><a class="reference internal" href="#pipeline-run" id="id15">Pipeline.Run</a></p></li>
<li><p><a class="reference internal" href="#g3pipelineinfo" id="id16">G3PipelineInfo</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="writing-a-module-in-python">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Writing a module in Python</a><a class="headerlink" href="#writing-a-module-in-python" title="Link to this heading">¶</a></h2>
<p>Modules can be written in Python in any one of three styles: as python functions, as subclasses of the base class core.G3Module, or as generic Python callables.</p>
<section id="python-modules-as-functions">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Python Modules as Functions</a><a class="headerlink" href="#python-modules-as-functions" title="Link to this heading">¶</a></h3>
<p>The simplest, and most common, case of a Python module is one that receives one frame, (potentially) modifies it, then passes it to the next module. This can be easily written as a simple Python function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simplemod</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">simplemod</span><span class="p">)</span>
</pre></div>
</div>
<p>This prints its input frame to the console, then implicitly passes it on to the next module in the chain.</p>
<p>As frames behave like Python dictionaries, the same approach can be used to modify frames:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">five</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;Five&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">five</span><span class="p">)</span>
</pre></div>
</div>
<p>The next module in the chain will now see a key named “Five” containing the number 5.</p>
<p>A full example of this doing something actually useful is to implement scan-by-scan poly-1 filtering of timestreams:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="k">def</span> <span class="nf">poly1</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3FrameType</span><span class="o">.</span><span class="n">Scan</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">outts</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3TimestreamMap</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;CalTimestreams&#39;</span><span class="p">]:</span>
                <span class="n">outts</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">key</span><span class="p">()]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3Timestream</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">units</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">units</span><span class="p">))</span>
        <span class="n">outts</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;CalTimestreams&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">outts</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;CalTimestreams&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;Poly1FilteredTimestreams&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">outts</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">poly1</span><span class="p">)</span>
</pre></div>
</div>
<p>This ignores non-scan frames and then creates a new timestream map containing a detrended version of the original, preserving the start and stop times and units. Right now, all the parameters of this processing step are hardcoded. It can be made configurable by the addition of keyword arguments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="k">def</span> <span class="nf">poly1</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="s1">&#39;CalTimestreams&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;Poly1FilteredTimestreams&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3FrameType</span><span class="o">.</span><span class="n">Scan</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">outts</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3TimestreamMap</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">[</span><span class="nb">input</span><span class="p">]:</span>
                <span class="n">outts</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">key</span><span class="p">()]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">G3Timestream</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">()))</span>
                <span class="n">outts</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">key</span><span class="p">()]</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">units</span>
        <span class="n">outts</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="nb">input</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
        <span class="n">outts</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="nb">input</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>
        <span class="n">frame</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">outts</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">poly1</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="s1">&#39;SomeOtherTimeStreams&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;OtherFilteredTimeStreams&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the module does not modify the original timestreams in place. This is deliberate (and, in fact, modules in C++ are not even able to do this). The rationale here is that overwriting data in place:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Makes it more confusing to trace the processing flow.</p></li>
<li><p>Prevents some optimizations with file IO.</p></li>
<li><p>Can create some causality paradoxes for certain kinds of data cached by modules.</p></li>
</ol>
</div></blockquote>
</section>
<section id="return-values-from-python-modules">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Return values from Python modules</a><a class="headerlink" href="#return-values-from-python-modules" title="Link to this heading">¶</a></h3>
<p>The examples above return <code class="docutils literal notranslate"><span class="pre">None</span></code> and so implicitly pass their input frame to the next module in the chain. Modules that need more control over data processing convey this by their return values:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">None</span></code></dt><dd><p>Passes input frame to the next module</p>
</dd>
<dt>A G3Frame object</dt><dd><p>Passes the return value to the next module <strong>instead of</strong> the input frame. This is usually used for the first module in a chain. The very first module has no data to work with and is responsible for generating it (see <a class="reference internal" href="#the-first-module">The first module</a>).</p>
</dd>
<dt>An iterable of G3Frames</dt><dd><p>Will insert the entire iterable (e.g. a Python list <code class="docutils literal notranslate"><span class="pre">[]</span></code>) of frames into the input queue for the next module. This can be used to inject new data mid-processing, for example to read in calibration data, by returning a list containing both the input frame and a new one. Note that returning an empty list (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) will cause the input frame to be dropped, which can be used to implement cuts. If the first module in the chain returns an empty list (<code class="docutils literal notranslate"><span class="pre">[]</span></code>), data processing will stop.</p>
</dd>
<dt>Something with truth value (e.g. <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>)</dt><dd><p>A return value of <code class="docutils literal notranslate"><span class="pre">True</span></code> will cause the input frame to be passed to the next module and is equivalent to returning <code class="docutils literal notranslate"><span class="pre">None</span></code>. Returning <code class="docutils literal notranslate"><span class="pre">False</span></code> will cause the input frame to be dropped and is equivalent to returning <code class="docutils literal notranslate"><span class="pre">[]</span></code>. This can be used to implement cuts by returning the value of a conditional expression.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="im-mutability-of-frame-objects">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">(Im)mutability of frame objects</a><a class="headerlink" href="#im-mutability-of-frame-objects" title="Link to this heading">¶</a></h3>
<p>Objects stored in a G3Frame are <em>immutable</em> – once added to a frame, they should not be modified. If you want to change the contents of a frame object, delete it from the frame, modify a copy, and add the copy to be frame. (In C++, the compiler will prevent in-place modifications since <code class="docutils literal notranslate"><span class="pre">G3Frame::Get()</span></code> returns a const pointer, but Python doesn’t have a concept of <code class="docutils literal notranslate"><span class="pre">const</span></code> so you just have to pay attention to the rules yourself and don’t get the compiler’s help). Copying the most common objects (e.g. G3TimestreamMaps) is designed to be particularly lightweight to facilitate this.</p>
<p>The immutability allows three particularly useful features of the software:</p>
<blockquote>
<div><ul class="simple">
<li><p>Any pipeline module can cache an object (e.g. calibration data) by reference, without using excess memory. If later modules had the ability to modify frame objects, this could change the past in some sense by changing previous pipeline stages’ view of the data after it was cached.</p></li>
<li><p>Serialization and deserialization of frame objects happens when frames are read from or written to disk and every time they pass through an MPI communicator or between members of a multiprocess group. To amortize this cost, G3Frame saves the original serialized copy of small (&lt; 128 MB) frame objects when deserialized and restores that copy to disk/MPI/etc. when the frame is saved again rather than pointlessly reserializing the unchanged object. If an object read from disk/MPI is modified in place and the frame is re-serialized, it will save the <em>original version</em> of the object, leading to a great deal of puzzling down the line.</p></li>
<li><p>The provenance of any object in the frame can be tracked at a high level since the only time things can change is when they are added to or deleted from a frame. This makes tracing where data came from in the pipeline <em>vastly</em> easier.</p></li>
</ul>
</div></blockquote>
<p><strong>CAUTION</strong>: An astute reader will notice that there are a few patterns that, while illegal in the strictest sense of the rules (they change frame-objects in place and a C++ compiler would reject them), will not create causality paradoxes (e.g. changing an object that a function has just added to a frame). Please proceed with great caution when writing such code.</p>
<p>For software connoisseurs: this is similar to, and exists for largely the same reasons as, the “single-static-assignment” architecture popular in modern compilers.</p>
</section>
<section id="the-first-module">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">The first module</a><a class="headerlink" href="#the-first-module" title="Link to this heading">¶</a></h3>
<p>The first module added to a <code class="docutils literal notranslate"><span class="pre">G3Pipeline</span></code> object is special: unlike all others, it does not act on input frames, since these frames cannot have come from anywhere. Instead, it is responsible for generating them. The <code class="docutils literal notranslate"><span class="pre">G3Reader</span></code> module is an example of this: it generates frames by reading them from disk.</p>
<p>Unlike all other modules, the first module will be passed <code class="docutils literal notranslate"><span class="pre">None</span></code> instead of a frame. This module then inserts data into the processing queue by returning new frames (see <a class="reference internal" href="#return-values-from-python-modules">Return values from Python modules</a>). Data processing will stop when it returns an empty list (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).</p>
</section>
<section id="callable-objects-as-functions">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Callable Objects as Functions</a><a class="headerlink" href="#callable-objects-as-functions" title="Link to this heading">¶</a></h3>
<p>In addition to Python functions, any Python callable (anything that implements the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method) can be used as a processing module. This can be useful for processing steps that need to maintain state, such as a map making module that needs to keep its in-progress map between scans. Semantics and return values are the same as for Python functions (see <a class="reference internal" href="#return-values-from-python-modules">Return values from Python modules</a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumberOfCalls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Output</span><span class="o">=</span><span class="s1">&#39;NCalls&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out</span> <span class="o">=</span> <span class="n">Output</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">frame</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">NumberOfCalls</span><span class="p">,</span> <span class="n">Output</span><span class="o">=</span><span class="s1">&#39;Calls&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>An alternative would be to subclass the <code class="docutils literal notranslate"><span class="pre">core.G3Module</span></code> class, which is more equivalent to the C++ mechanism but makes no practical difference at all, except that it will be automatically documented (see <a class="reference internal" href="#autodocumentation-of-modules">Autodocumentation of modules</a>). The only other difference is that the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method is renamed <code class="docutils literal notranslate"><span class="pre">Process</span></code> in this case:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumberOfCalls</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">G3Module</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Output</span><span class="o">=</span><span class="s1">&#39;NCalls&#39;</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">NumberOfCalls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out</span> <span class="o">=</span> <span class="n">Output</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="nf">Process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">frame</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncalls</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">NumberOfCalls</span><span class="p">,</span> <span class="n">Output</span><span class="o">=</span><span class="s1">&#39;Calls&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="autodocumentation-of-modules">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Autodocumentation of modules</a><a class="headerlink" href="#autodocumentation-of-modules" title="Link to this heading">¶</a></h3>
<p>Preceding your module with the <code class="docutils literal notranslate"><span class="pre">&#64;core.indexmod</span></code> decorator will allow the <code class="docutils literal notranslate"><span class="pre">spt3g-inspect</span></code> tool to list it. This should be used for processing steps designed for public use <em>only</em> rather than one-off functions for internal use in larger blocks of code.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@core</span><span class="o">.</span><span class="n">indexmod</span>
<span class="k">def</span> <span class="nf">printframe</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Print frame to console&#39;&#39;&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
</pre></div>
</div>
<p>will produce the following output of <code class="docutils literal notranslate"><span class="pre">spt3g-inspect</span></code>:</p>
<blockquote>
<div><p>— Processing module: spt3g.example.printframe —
Print frame to console</p>
</div></blockquote>
<p>All subclasses of <code class="docutils literal notranslate"><span class="pre">core.G3Module</span></code> (both in Python and C++) are automatically treated as though they were marked with this decorator.</p>
</section>
</section>
<section id="writing-a-module-in-c">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Writing a module in C++</a><a class="headerlink" href="#writing-a-module-in-c" title="Link to this heading">¶</a></h2>
<p>The process of writing a processing module in C++ is similar to the Python one. C++ modules use a slightly different interface than Python; in particular, they behave like the callable object interface where all methods return lists.</p>
<p>A C++ module must inherit from the <code class="docutils literal notranslate"><span class="pre">G3Module</span></code> class. Data processing happens through the <code class="docutils literal notranslate"><span class="pre">Process</span></code> method, which takes two arguments: an input frame and an output queue. Output frames are pushed onto the queue; the semantics of this output queue are identical to those for Python processing modules returning lists.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;G3Frame.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;G3Module.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;G3Data.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pybindings.h&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Five</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">G3Module</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">G3FramePtr</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">G3FramePtr</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="s">&quot;Five&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">G3IntPtr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">G3Int</span><span class="p">(</span><span class="mi">5</span><span class="p">)));</span>
<span class="w">                </span><span class="n">out</span><span class="p">.</span><span class="n">push_pack</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">EXPORT_G3MODULE</span><span class="p">(</span><span class="s">&quot;exampleproject&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Five</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Adds five&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This example creates a module called <code class="docutils literal notranslate"><span class="pre">Five</span></code> that, like the earlier Python example, adds a key named <code class="docutils literal notranslate"><span class="pre">Five</span></code> to every frame. It is a part of the library “exampleproject” and will be accessible from Python as <code class="docutils literal notranslate"><span class="pre">exampleproject.Five</span></code>.</p>
<p>Interaction with Python occurs through the <code class="docutils literal notranslate"><span class="pre">EXPORT_G3MODULE()</span></code> macro. The first two arguments are the library name and class to export. The third gives the arguments to the constructor (none, in this case). The fourth is the docstring visible for the class in Python. An example configurable version of the class follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;G3Frame.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;G3Module.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;G3Data.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Five</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">G3Module</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Five</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Five&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">output_</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">Process</span><span class="p">(</span><span class="n">G3FramePtr</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">G3FramePtr</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="n">output_</span><span class="p">,</span><span class="w"> </span><span class="n">G3IntPtr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">G3Int</span><span class="p">(</span><span class="mi">5</span><span class="p">)));</span>
<span class="w">                </span><span class="n">out</span><span class="p">.</span><span class="n">push_pack</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">output_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">EXPORT_G3MODULE</span><span class="p">(</span><span class="s">&quot;exampleproject&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Five</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="o">&lt;</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">(</span><span class="s">&quot;output&quot;</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;Adds five&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">init&lt;&gt;</span></code> arguments are modified to reflect that the configuration parameter is a string, that it is optional (leaving out the <code class="docutils literal notranslate"><span class="pre">optional&lt;&gt;</span></code> will make it mandatory), and that it maps to a Python keyword argument named “output”. If your constructor takes multiple arguments, enclose the entire init section in parentheses to avoid preprocessor errors.</p>
</section>
<section id="pipeline-segments">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Pipeline Segments</a><a class="headerlink" href="#pipeline-segments" title="Link to this heading">¶</a></h2>
<p>The use of pipeline segments allows you to have a canned collection of modules that can be added to a pipeline as though it were a single module. An example would be a pipeline segment that performs standard timestream filtering, which may be made of many separate modules but where specifying them individually would be tedious and prone to error.</p>
<p>A pipeline segment is defined by a Python function that is marked by the <code class="docutils literal notranslate"><span class="pre">&#64;core.pipesegment</span></code> decorator and takes a pipeline as its first argument. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@core</span><span class="o">.</span><span class="n">pipesegment</span>
<span class="k">def</span> <span class="nf">standardfiltering</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="s1">&#39;CalTimestreams&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;OutTimestreams&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is the standard timestream filtering used for 2016 data</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">PolyFilter</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="nb">input</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">MaskedHighPassFilter</span><span class="p">,</span> <span class="n">ell</span><span class="o">=</span><span class="mi">3000</span><span class="p">)</span>

<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">standardfiltering</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;FilteredTimestreams&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">core.pipesegment</span></code> decorator will introspect these functions by running them against a fake pipeline object. This information about what the segment does is then automatically appended to the docstring for the segment. This makes it easy for a user to discover what your wrapper does in a way that cannot become inconsistent with documentation. If your pipeline segment has side effects (e.g. opening files) or cannot be run with its default arguments, you may wish to disable this behavior by passing the <code class="docutils literal notranslate"><span class="pre">autodoc=False</span></code> keyword argument to the decorator.</p>
</section>
<section id="advanced-techniques-buffering-data">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Advanced Techniques: Buffering Data</a><a class="headerlink" href="#advanced-techniques-buffering-data" title="Link to this heading">¶</a></h2>
<p>Modules that need to work on granularilty coarser than a scan (e.g. notch filtering) can <strong>buffer</strong> frames. This can be implemented using the Python callable interface. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Buffered</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="c1"># Add to buffer and move to the next scan</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                        <span class="k">return</span> <span class="p">[]</span>

                <span class="c1"># Now we have 5 frames queued up</span>
                <span class="n">dostuffwithfivescans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span>

                <span class="c1"># Clear buffer and send these frames onward</span>
                <span class="n">returnval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">return</span> <span class="n">returnval</span>
</pre></div>
</div>
<p>This implements a processing step that works on five scans at a time. From the perspective of a module either before or after this one in the chain, nothing unusual happens: frames appear in order one at a time in both cases. When <code class="docutils literal notranslate"><span class="pre">__call__</span></code> returns an empty list, the pipeline goes back to the first module to get a new frame instead of continuing to the next. These accumulate inside the internal queue of <code class="docutils literal notranslate"><span class="pre">Buffered</span></code> until there are five scans present. At that point, they are processed as a group and then moved to the output queue. When the pipeline sees five frames in the output queue, it will call the next module five times, with each frame in sequence. Once that is complete, it will then go back to the first module for new frames.</p>
</section>
<section id="caching-previous-data">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Caching Previous Data</a><a class="headerlink" href="#caching-previous-data" title="Link to this heading">¶</a></h2>
<p>The previous example can be adapted to cache data from previous frames when that data is required to operate on current frames.  This is useful for caching e.g. calibration data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Caching</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calibrator_key</span><span class="o">=</span><span class="s1">&#39;CalibratorResponse&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calkey</span> <span class="o">=</span> <span class="n">calibrator_key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calkey</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cal</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">calkey</span><span class="p">]</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">G3FrameType</span><span class="o">.</span><span class="n">Scan</span><span class="p">:</span>
                <span class="c1"># Do something here</span>
</pre></div>
</div>
<p>There are two convenience methods for caching data and passing it into a module.  This is useful for writing a function that requires (for example) a <code class="docutils literal notranslate"><span class="pre">BolometerPropertiesMap</span></code>, but otherwise does not require a class.  This is best illustrated with an example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@core</span><span class="o">.</span><span class="n">cache_frame_data</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">core</span><span class="o">.</span><span class="n">G3FrameType</span><span class="o">.</span><span class="n">Scan</span><span class="p">,</span> <span class="n">bolo_props</span><span class="o">=</span><span class="s1">&#39;BolometerProperties&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">FlagSomeStuff</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">flag_key</span><span class="o">=</span><span class="s1">&#39;Flags&#39;</span><span class="p">,</span> <span class="n">bolo_props</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The decorator <code class="docutils literal notranslate"><span class="pre">&#64;core.cache_frame_data</span></code> will ensure that the bolometer properties are passed to <code class="docutils literal notranslate"><span class="pre">FlagSomeStuff</span></code> in the <code class="docutils literal notranslate"><span class="pre">bolo_props</span></code> kwarg.  The (required) <code class="docutils literal notranslate"><span class="pre">type</span></code> argument specifies that <code class="docutils literal notranslate"><span class="pre">FlagSomeStuff</span></code> only runs on frames of type <code class="docutils literal notranslate"><span class="pre">core.G3FrameType.Scan</span></code>.  When called with an abritrary <code class="docutils literal notranslate"><span class="pre">kwarg='FrameKey'</span></code> pair, <code class="docutils literal notranslate"><span class="pre">core.cache_frame_data</span></code> caches the most recent instance of <code class="docutils literal notranslate"><span class="pre">'FrameKey'</span></code> in any frame, and passes it to the decorated function under the keyword argument <code class="docutils literal notranslate"><span class="pre">kwarg</span></code>.  <code class="docutils literal notranslate"><span class="pre">core.cache_frame_data</span></code> can cache multiple keys from multiple frames.  For example, if one wanted to cache the calibrator singal to noise ratio (stored as <code class="docutils literal notranslate"><span class="pre">'CalibratorResponseSN'</span></code>) as well as the bolometer properties, and pass it to a function with the keyword argument <cite>calsn</cite>, one would wrap that function with the decorator <code class="docutils literal notranslate"><span class="pre">&#64;core.cache_frame_data(type=core.G3FrameType.Scan,</span> <span class="pre">calsn='CalibratorResponseSN',</span> <span class="pre">bolo_props='BolometerProperties')</span></code>.  This would be useful if one wanted to apply different calibrator SNR thresholds to different bands, for example.</p>
<p><code class="docutils literal notranslate"><span class="pre">core.scan_func_cache_data</span></code> is a special case of <code class="docutils literal notranslate"><span class="pre">core.cache_frame_data</span></code> where <code class="docutils literal notranslate"><span class="pre">type</span></code> is set to <code class="docutils literal notranslate"><span class="pre">core.G3FrameType.Scan</span></code>.</p>
</section>
<section id="pipelines">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Pipelines</a><a class="headerlink" href="#pipelines" title="Link to this heading">¶</a></h2>
<p>Modules are connected to one another by a pipeline object, of which there is currently one implementation: G3Pipeline. Any pipeline has two interesting methods, <code class="docutils literal notranslate"><span class="pre">Add</span></code> and <code class="docutils literal notranslate"><span class="pre">Run</span></code>.</p>
<section id="pipeline-add">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Pipeline.Add</a><a class="headerlink" href="#pipeline-add" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Add()</span></code> method adds a module to the pipeline immediately following the last added module. It accepts any of the module types described above, as well as pipeline segments. For classes (either C++ or Python), it can accept either an instance of the module or the class. If passed a class, keyword arguments following the class are passed to the class constructor. The following two pieces of code are equivalent:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">G3Pipeline</span><span class="p">()</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">G3Reader</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;test.g3&quot;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe</span> <span class="o">=</span> <span class="n">G3Pipeline</span><span class="p">()</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">G3Reader</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;test.g3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For pipeline segments, only the second syntax works. As a result, the second syntax is generally preferred, as it can be used uniformly for all objects that can be passed to <code class="docutils literal notranslate"><span class="pre">Add()</span></code>. Additionally, only the second syntax will record configuration information (see <a class="reference internal" href="#g3pipelineinfo">G3PipelineInfo</a>).</p>
<p><code class="docutils literal notranslate"><span class="pre">Add()</span></code> accepts a special keyword argument (<code class="docutils literal notranslate"><span class="pre">name</span></code>) that can be used to set the name of a module or segment in the output of run profiling (see below). If unspecified, it defaults to the name of the class or function, with slashes indexing modules added by pipeline segments.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">subprocess</span></code> argument to <code class="docutils literal notranslate"><span class="pre">Add()</span></code> is set to True, the module passed will be run in a python subprocess using the multiprocessing framework. Note that this does <em>not</em> work yet for segments.</p>
</section>
<section id="pipeline-run">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Pipeline.Run</a><a class="headerlink" href="#pipeline-run" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Run()</span></code> method runs the pipeline until completion (see <a class="reference internal" href="#the-first-module">The first module</a>). It takes one optional keyword argument (<code class="docutils literal notranslate"><span class="pre">profile</span></code>). If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, it will print out the amount of system and user time spent in that module during processing after completion.</p>
</section>
<section id="g3pipelineinfo">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">G3PipelineInfo</a><a class="headerlink" href="#g3pipelineinfo" title="Link to this heading">¶</a></h3>
<p>G3Pipeline will automatically insert information about its configuration into the data stream by internally emitting a PipelineInfo frame containing a timestamped G3PipelineInfo object with the following information:</p>
<ul class="simple">
<li><p>Version control information (branch, revision number, source URL, version name if any, presence of local diffs, etc.) reflecting the software currently running.</p></li>
<li><p>The user and host running the software.</p></li>
<li><p>The configuration of all modules and/or segments added to the pipeline.</p></li>
</ul>
<p>This information is added immediately following the first added module or segment. If the first frame in the data stream at this point is already a PipelineInfo frame (or a PipelineInfo frame occurs in one of the first few frames, with only metadata frames before it), the G3PipelineInfo object described above will be added to it; otherwise, a new PipelineInfo frame with the object is prepended to the data stream.</p>
<p>Within some limits imposed by Python (related to lambda functions, most notably), calling <code class="docutils literal notranslate"><span class="pre">repr()</span></code> on a G3PipelineInfo object (or a G3Pipeline object) will yield an executable Python script reflecting the exact modules and configuration used to produce the data. To within the mentioned limitations, this script can be rerun to exactly reproduce stored data; it can also be inspected to learn the configuration of the data’s source pipeline[s] and thus the processing that produced it.</p>
<p>The G3PipelineInfo <code class="docutils literal notranslate"><span class="pre">.Run()</span></code> method provides a convenient way of rerunning the pipeline configuration within it, and the <code class="docutils literal notranslate"><span class="pre">.modules</span></code> attribute is a list of G3ModuleConfig objects with dict-like access to the arguments provided to each pipeline module.</p>
<p>Limitations:</p>
<ul class="simple">
<li><p>The content of functions defined inline in a script (either by <code class="docutils literal notranslate"><span class="pre">def</span></code> or <code class="docutils literal notranslate"><span class="pre">lambda</span></code>), as opposed to functions defined in an imported Python module, will not appear in the output, though options will. Inline functions defined by <code class="docutils literal notranslate"><span class="pre">def</span></code> will at least give the name of the function.</p></li>
<li><p>Options passed to pre-instantiated modules will not be stored. Only options passed in <code class="docutils literal notranslate"><span class="pre">pipe.Add()</span></code> will be recorded. For example, <code class="docutils literal notranslate"><span class="pre">pipe.Add(core.G3Reader,</span> <span class="pre">filename=&quot;test.g3&quot;)</span></code> will fully record its arguments, but <code class="docutils literal notranslate"><span class="pre">pipe.Add(core.G3Reader(filename=&quot;test.g3&quot;))</span></code> will not. Prefer the syntax that records options unless you have a compelling reason to do something else.</p></li>
<li><p>A G3Pipeline created in C++ will not record configuration; only G3Pipelines created in Python will.</p></li>
<li><p>If the code used to run the pipeline initially has changed, rerunning the configuration from the G3PipelineInfo object will produce different results.  Use the version control information stored in the object to ensure you are running the correct version of the software.</p></li>
</ul>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Modules</a><ul>
<li><a class="reference internal" href="#writing-a-module-in-python">Writing a module in Python</a><ul>
<li><a class="reference internal" href="#python-modules-as-functions">Python Modules as Functions</a></li>
<li><a class="reference internal" href="#return-values-from-python-modules">Return values from Python modules</a></li>
<li><a class="reference internal" href="#im-mutability-of-frame-objects">(Im)mutability of frame objects</a></li>
<li><a class="reference internal" href="#the-first-module">The first module</a></li>
<li><a class="reference internal" href="#callable-objects-as-functions">Callable Objects as Functions</a></li>
<li><a class="reference internal" href="#autodocumentation-of-modules">Autodocumentation of modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#writing-a-module-in-c">Writing a module in C++</a></li>
<li><a class="reference internal" href="#pipeline-segments">Pipeline Segments</a></li>
<li><a class="reference internal" href="#advanced-techniques-buffering-data">Advanced Techniques: Buffering Data</a></li>
<li><a class="reference internal" href="#caching-previous-data">Caching Previous Data</a></li>
<li><a class="reference internal" href="#pipelines">Pipelines</a><ul>
<li><a class="reference internal" href="#pipeline-add">Pipeline.Add</a></li>
<li><a class="reference internal" href="#pipeline-run">Pipeline.Run</a></li>
<li><a class="reference internal" href="#g3pipelineinfo">G3PipelineInfo</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="quickstart.html"
                          title="previous chapter">Quick Start</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="frames.html"
                          title="next chapter">Frames</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modules.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="frames.html" title="Frames"
             >next</a> |</li>
        <li class="right" >
          <a href="quickstart.html" title="Quick Start"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPT3G Software  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Modules</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>